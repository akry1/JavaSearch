Set cannot have duplicates in it. You may wonder how duplicates are detected when we are adding an object to the Set. We have to see if that object exists in the Set or not. It is not enough to check the object references, the objects' values have to be checked as well.<br />To do that, fortunately, each java object has the boolean equals(Object obj), method available inherited from Object. You need to override it. That method will be called by the Set implementation to compare the two objects to see if they are equal or not.<br />There is a problem, though. What if I put two different type of objects to the Set. I put an Apple and an Orange. They can not be compared. Calling the equals() method would cause a ClassCastException. There are two solutions to this:<br /><br />Solution one : Override the int hashCode() method and return the same values for the same type of objects and return different values for different type of objects. The equals() method is used to compare objects only with the same value of hashCode. So before an object is added, the Set implementation needs to:<br /><br />find all the objects in the Set that have the same hashCode as the candidate object hashCode<br />and for those, call the equals() methods passing in the candidate object<br />if any of them returns true, the object is not added to the Set.<br /><br /><br /><br /><br />Solution two : Create a super class for the Apple and Orange, let's call it Fruit class. Put Fruits in the Set. You need to do the following:<br /><br />Do not override the equals() and hashCode() methods in the Apple and Orange classes<br />Create appleEquals() method in the Apple class, and create orangeEquals() method in the Orange class<br />Override the hashCode() method in the Fruit class and return the same value, so the equals() is called by the Set implementation<br />Override the equals() method in the Fruit class for something like this.<br /><br /><br /><br /><br /><br /><br />Code section 5.5: equals method implementation.<br /><br /><br /> 1 public boolean equals(Object obj) {<br /> 2     boolean ret = false;<br /> 3     if (this instanceof Apple &&<br /> 4           obj instanceof Apple) {<br /> 5         ret = this.appleEquals(obj);<br /> 6     } else if (this instanceof Orange &&<br /> 7               obj  instanceof Orange) {<br /> 8         ret = this.orangeEquals(obj);  <br /> 9     } else {<br />10         // Can not compare Orange to Apple<br />11        ret = false;<br />12     }<br />13     return ret;<br />14 }<br /><br /><br /><br /><br />Note:<br /><br />Only the objects that have the same hashCode will be compared.<br />You are responsible to override the equals() and hashCode() methods. The default implementations in Object won't work.<br />Only override the hashCode() method if you want to eliminate value duplicates.<br />Do not override the hashCode() method if you know that the values of your objects are different, or if you only want to prevent adding the exactly same object.<br />Beware that the hashCode() may be used in other collection implementations, like in a Hashtable to find an object fast. Overriding the default hashCode() method may affect performance there.<br />The default hashCodes are unique for each object created, so if you decide not to override the hashCode() method, there is no point overriding the equals() method, as it won't be called.