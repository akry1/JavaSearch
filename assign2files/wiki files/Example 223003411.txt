As an example we can write a simple Foo.java source:<br /><br /><br />public class Foo {<br />  public static void main(final String[] args) {<br />    System.out.println("This is a simple example of decompilation using javap");<br />    a();<br />    b();<br />  }<br />	<br />  public static void a() {<br />    System.out.println("Now we are calling a function...");<br />  }<br /><br />  public static void b() {<br />    System.out.println("...and now we are calling b");<br />  }<br />}<br /><br />Compile it and then move Foo.java to another directory or delete it if you wish. What can we do with javap and Foo.classÂ ?<br /><br />$javap Foo<br /><br />produces this result:<br /><br />Compiled from "Foo.java"<br />public class Foo extends java.lang.Object {<br />    public Foo();<br />    public static void main(java.lang.String[]);<br />    public static void a();<br />    public static void b();<br />}<br /><br />As you can see the javac compiler doesn't strip any (public) variable name from the .class file. As a result the names of the functions, their parameters and types of return are exposed. (This is necessary in order for other classes to access them.)<br />Let's do a bit more, try:<br /><br />$javap -c Foo<br /><br /><br />Compiled from "Foo.java"<br />public class Foo extends java.lang.Object{<br />public Foo();<br />  Code:<br />   0:   aload_0<br />   1:   invokespecial   #1; //Method java/lang/Object."<init>":()V<br />   4:   return<br /><br />public static void main(java.lang.String[]);<br />  Code:<br />   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;<br />   3:   ldc             #3; //String This is a simple example of decompilation using javap<br />   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V<br />   8:   invokestatic    #5; //Method a:()V<br />   11:  invokestatic    #6; //Method b:()V<br />   14:  return<br /><br />public static void a();<br />  Code:<br />   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;<br />   3:   ldc             #7; //String Now we are calling a function...<br />   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V<br />   8:   return<br /><br />public static void b();<br />  Code:<br />   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;<br />   3:   ldc             #8; //String ...and now we are calling b<br />   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V<br />   8:   return<br /><br />}