A generic class does not hard code the type of a field, a return value or a parameter. The class only indicates that a generic type should be the same, for a given object instance. The generic type is not specified in the class definition. It is specified during object instantiation. This allows the generic type to be different from an instance to another. So we should write our class this way:<br /><br /><br /><br />Code listing 4.36: Repository.java<br /><br /><br /> 1 public class Repository<T> {<br /> 2 <br /> 3    public T item;<br /> 4 <br /> 5    public T getItem() {<br /> 6       return item;<br /> 7    }<br /> 8 <br /> 9    public void setItem(T newItem) {<br />10       item = newItem;<br />11    }<br />12 }<br /><br /><br /><br /><br />Here, the generic type is defined after the name of the class. Any new identifier can be chosen. Here, we have chosen T, which is the most common choice. The actual type is defined at the object instantiation:<br /><br /><br /><br />Code section 4.35: Instantiation.<br /><br /><br />1 Repository<Integer> arithmeticRepository = new Repository<Integer>();<br />2 arithmeticRepository.setItem(new Integer(1));<br />3 Integer number = arithmeticRepository.getItem();<br />4 <br />5 Repository<String> textualRepository = new Repository<String>();<br />6 textualRepository.setItem("Hello!");<br />7 String message = textualRepository.getItem();<br /><br /><br /><br /><br />Although each object instance has its own type, each object instance is still strongly typed:<br /><br /><br /><br />Code section 4.36: Compile error.<br /><br /><br />1 Repository<Integer> arithmeticRepository = new Repository<Integer>();<br />2 arithmeticRepository.setItem("Hello!");<br /><br /><br /><br /><br /><br />A class can define as many generic types as you like. Choose a different identifier for each generic type and separate them by a comma:<br /><br /><br /><br />Code listing 4.37: Repository.java<br /><br /><br /> 1 public class Repository<T, U> {<br /> 2 <br /> 3    public T item;<br /> 4 <br /> 5    public U anotherItem;<br /> 6 <br /> 7    public T getItem() {<br /> 8       return item;<br /> 9    }<br />10 <br />11    public void setItem(T newItem) {<br />12       item = newItem;<br />13    }<br />14 <br />15    public U getAnotherItem() {<br />16       return anotherItem;<br />17    }<br />18 <br />19    public void setAnotherItem(U newItem) {<br />20       anotherItem = newItem;<br />21    }<br />22 }<br /><br /><br /><br /><br />When a type that is defined with generic (for example, Collection<T>) is not used with generics (for example, Collection) is called a raw type.