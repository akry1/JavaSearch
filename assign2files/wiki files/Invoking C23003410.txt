You can use Runtime.exec() method to invoke a program from within a running Java application. Runtime.exec() also allows you to perform operations related to the program, such as control the program's standard input and output, wait until it completes execution, and get its exit status.<br />Here's a simple C application that illustrates these features. This C program will be called from Java:<br /><br /><br />#include <stdio.h><br /><br />int main() {<br />    printf("testing\n");<br />    return 0;<br />}<br /><br />This application writes a string "testing" to standard output, and then terminates with an exit status of 0. To execute this simple program within a Java application, compile the C application:<br /><br /><br /><br />Compilation<br /><br />$ cc test.c -o test<br /><br /><br /><br />Then invoke the C program using this Java code:<br /><br /><br /><br />Code listing 10.2: Invoking C programs.<br /><br /><br /> 1 import java.io.InputStream;<br /> 2 import java.io.BufferedReader;<br /> 3 import java.io.InputStreamReader;<br /> 4 import java.io.IOException;<br /> 5 import java.io.InterruptedException;<br /> 6 import java.io.Process;<br /> 7 import java.io.Runtime;<br /> 8 <br /> 9 import java.util.ArrayList;<br />10 <br />11 public class ExecDemo {<br />12     public static String[] runCommand(String cmd) throws IOException {<br />13         // --- set up list to capture command output lines ---<br />14         ArrayList list = new ArrayList();<br />15 <br />16         // --- start command running<br />17         Process proc = Runtime.getRuntime().exec(cmd);<br />18 <br />19         // --- get command's output stream and<br />20         // put a buffered reader input stream on it ---<br />21         InputStream istr = proc.getInputStream();<br />22         BufferedReader br = new BufferedReader(new InputStreamReader(istr));<br />23 <br />24         // --- read output lines from command<br />25         String str;<br />26         while ((str = br.readLine()) != null) {<br />27             list.add(str);<br />28         }<br />29 <br />30         // wait for command to terminate<br />31         try {<br />32             proc.waitFor();<br />33         }<br />34         catch (InterruptedException e) {<br />35             System.err.println("process was interrupted");<br />36         }<br />37 <br />38         // check its exit value<br />39         if (proc.exitValue() != 0) {<br />40             System.err.println("exit value was non-zero");<br />41         }<br />42 <br />43         // close stream<br />44         br.close();<br />45 <br />46         // return list of strings to caller<br />47         return (String[])list.toArray(new String[0]);<br />48     }<br />49 <br />50     public static void main(String args[]) throws IOException {<br />51         try {<br />52 <br />53             // run a command<br />54             String outlist[] = runCommand("test");<br />55 <br />56             // display its output<br />57             for (int i = 0; i < outlist.length; i++)<br />58                 System.out.println(outlist[i]);<br />59         }<br />60         catch (IOException e) {<br />61             System.err.println(e);<br />62         }<br />63     }<br />64 }<br /><br /><br /><br /><br />The demo calls a method runCommand to actually run the program.<br /><br /><br /><br />Code section 10.1: Running a command.<br /><br /><br />1 String outlist[] = runCommand("test");<br /><br /><br /><br /><br />This method hooks an input stream to the program's output stream, so that it can read the program's output, and save it into a list of strings.<br /><br /><br /><br />Code section 10.2: Reading the program's output.<br /><br /><br />1 InputStream istr = proc.getInputStream();<br />2 BufferedReader br = new BufferedReader(new InputStreamReader(istr));<br />3              <br />4 String str;<br />5 while ((str = br.readLine()) != null) {<br />6     list.add(str);<br />7 }