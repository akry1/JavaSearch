In a list collection, the elements are put in a certain order, and can be accessed by an index. Duplicates are allowed, the same element can be added twice to a list. It has the following implementations:<br /><br /><br /><br />Figure 3: List class diagram.<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />java.util.Vector<E> <br />Synchronized, use in multiple thread access, otherwise use ArrayList.<br />java.util.Stack<E> <br />It extends class Vector with five operations that allow a vector to be treated as a stack. It represents a last-in-first-out (LIFO) stack of objects.<br />java.util.ArrayList<E> <br />The basic implementation of the List interface is the ArrayList. The ArrayList is not synchronized, not thread safe. Vector is synchronized, and thread safe. Vector is slower, because of the extra overhead to make it thread safe. When only one thread is accessing the list, use the ArrayList. Whenever you insert or remove an element from the list, there are extra overhead to reindex the list. When you have a large list, and you have lots of insert and remove, consider using the LinkedList.<br />java.util.LinkedList<E> <br />Non-synchronized, update operation is faster than other lists, easy to use for stacks, queues, double-ended queues. The name LinkedList implies a special data structure where the elements/nodes are connected by pointers.<br /><br /><br /> Head               Node 1                   Node 2                     Node n<br />  ______<br /> | Size |          _________________        _______________            _____________<br /> |______|         |      | point   |       |      | point  |          |      |      |  <br /> | First|-------->| Data | to next |------>| Data | to next|-- ... -->| Data | null |<br /> | elem |         |______|_________|       |______|________|          |______|______|<br /> |______|                                                                 ^<br /> | Last |                                                                 |<br /> | elem |-----------------------------------------------------------------<br /> |______|<br /><br />Each node is related to an item of the linked list. To remove an element from the linked list the pointers need to be rearranged. After removing Node 2:<br /><br /> Head               Node 1                   Node 2                     Node n<br />  ______                                 _____________________<br /> | Size |          _________________    |   _______________   |       ______________<br /> |_- 1__|         |      | point   |    |  |      | point  |  |       |      |      |  <br /> | First|-------->| Data | to next |----   | Data | to next|   -...-->| Data | null |<br /> | elem |         |______|_________|       |______|________|          |______|______|<br /> |______|                                                                 ^<br /> | Last |                                                                 |<br /> | elem |-----------------------------------------------------------------<br /> |______|<br /><br /><br />javax.management.AtributeList<E> <br />Represents a list of values for attributes of an MBean. The methods used for the insertion of Attribute objects in the AttributeList overrides the corresponding methods in the superclass ArrayList. This is needed in order to insure that the objects contained in the AttributeList are only Attribute objects.<br />javax.management.relation.RoleList<E> <br />A RoleList represents a list of roles (Role objects). It is used as parameter when creating a relation, and when trying to set several roles in a relation (via 'setRoles()' method). It is returned as part of a RoleResult, to provide roles successfully retrieved.<br />javax.management.relation.RoleUnresolvedList<E> <br />A RoleUnresolvedList represents a list of RoleUnresolved objects, representing roles not retrieved from a relation due to a problem encountered when trying to access (read or write to roles).