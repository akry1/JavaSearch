Aside from the java.util.Collection interface, the Java JDK has the java.util.Map interface as well. It is sometimes also called an Associated Array or a Dictionary. A map defines key value mappings. Implementations of the Map interface do not contain collections of objects. Instead they contain collections of key->value mappings. It can be thought of as an array where the index doesn't need to be an integer.<br /><br /><br /><br />Code section 5.17: Use of a map.<br /><br /><br />1 import java.util.Map;<br />2 import java.util.Hashtable;<br />3 ...<br />4 Map map = new Hashtable();<br />5 ...<br />6 map.put(key, value);<br /><br /><br /><br /><br />Use the Map interface if you need to keep related objects together in a Map where you can:<br /><br />Access an element by a key object<br />Map one object to other<br /><br /><br /><br /><br /><br />Figure 5.6: Map Interfaces.<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />java.util.Map<K,V> <br />maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value. The Map interface provides three collection views, which allow a map's contents to be viewed as a set of keys, collection of values, or set of key-value mappings. The key is usually a non-mutable object. The value object however can be a mutable object.<br />java.util.SortedMap<K,V> <br />same as the Map interface, plus the keys in the Map are sorted.<br /><br />In the above example, the same operations are made with two different map implementations:<br /><br /><br /><br /><br /><br /><br />Code listing 5.4: MapImplementations.java<br /><br /><br /> 1 import java.util.LinkedHashMap;<br /> 2 import java.util.Map;<br /> 3 import java.util.TreeMap;<br /> 4 <br /> 5 /**<br /> 6  * Compare the map implementations.<br /> 7  *<br /> 8  * @author xxx<br /> 9  */<br />10 public class MapImplementations {<br />11 <br />12   /**<br />13    * Compare the map implementations.<br />14    * @param args The execution parameters.<br />15    */<br />16   public static void main(String[] args) {<br />17     processMap(new LinkedHashMap<String, Integer>());<br />18 <br />19     processMap(new TreeMap<String, Integer>());<br />20   }<br />21 <br />22   /**<br />23    * Use a map:<br />24    * 1. Fill the map with key-> value.<br />25    * 2. Print all the keys.<br />26    *<br />27    * @param map The used map.<br />28    */<br />29   public static void processMap(Map<String, Integer> map) {<br />30     System.out.println("Process the map");<br />31     map.put("3", new Integer(3));<br />32     map.put("2", new Integer(2));<br />33     map.put("1", new Integer(1));<br />34 <br />35     for (String key : map.keySet()) {<br />36       System.out.println(key);<br />37     }<br />38   }<br />39 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Console for Code listing 5.4<br /><br />Process the map<br />3<br />2<br />1<br />Process the map<br />1<br />2<br />3<br /><br /><br /><br /><br /><br /><br />We see that only the TreeMap has sorted the keys. Beware of the generics. The Map interface is tricky. The methods get() and remove() are not generic. This means that you must be careful of the type of the key:<br /><br /><br /><br /><br /><br /><br />Code section 5.18: Tricky generics.<br /><br /><br /> 1 Map<Integer, String> map = new TreeMap<Integer, String>();<br /> 2 <br /> 3 map.put(new Integer(1), "Watch");<br /> 4 map.put(new Integer(2), "out");<br /> 5 map.put(new Integer(3), "!");<br /> 6 <br /> 7 map.remove("2");<br /> 8 <br /> 9 for (String value : map.values()) {<br />10   System.out.println(value);<br />11 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Console for Code section 5.18<br /><br />Watch<br />out<br />!<br /><br /><br /><br /><br /><br /><br />The remove() call has done nothing because "2" is a String, not an Integer so no key and value has been found and removed.