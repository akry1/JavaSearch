Native data types can be mapped to/from Java data types. For compound types such as objects, arrays and strings the native code must explicitly convert the data by calling methods in the JNIEnv. The following table shows the mapping of types between Java (JNI) and native code.<br /><br /><br />Native Type<br />JNI Type<br />Description<br />Type signature<br /><br /><br />unsigned char<br />jboolean<br />unsigned 8 bits<br />Z<br /><br /><br />signed char<br />jbyte<br />signed 8 bits<br />B<br /><br /><br />unsigned short<br />jchar<br />unsigned 16 bits<br />C<br /><br /><br />short<br />jshort<br />signed 16 bits<br />S<br /><br /><br />long<br />jint<br />signed 32 bits<br />I<br /><br /><br /><br />long long<br />__int64<br /><br />jlong<br />signed 64 bits<br />J<br /><br /><br />float<br />jfloat<br />32 bits<br />F<br /><br /><br />double<br />jdouble<br />64 bits<br />D<br /><br /><br />In addition, the signature "L fully-qualified-classÂ ;" would mean the class uniquely specified by that name; e.g., the signature "Ljava/lang/String;" refers to the class java.lang.String. Also, prefixing [ to the signature makes the array of that type; for example, [I means the int array type. Finally, a void signature uses the V code. Here, these types are interchangeable. You can use jint where you normally use an int, and vice-versa, without any typecasting required.<br />However, mapping between Java Strings and arrays to native strings and arrays is different. If you use a jstring in where a char * would be, your code could crash the JVM.<br /><br /><br />JNIEXPORT void JNICALL Java_ClassName_MethodName<br />        (JNIEnv *env, jobject obj, jstring javaString) {<br />    // printf("%s", javaString);        // INCORRECT: Could crash VM!<br /><br />    // Correct way: Create and release native string from Java string<br />    const char *nativeString = (*env)->GetStringUTFChars(env, javaString, 0);<br />    printf("%s", nativeString);<br />    (*env)->ReleaseStringUTFChars(env, javaString, nativeString);<br />}<br /><br />The encoding used for the NewStringUTF, GetStringUTFLength, GetStringUTFChars, ReleaseStringUTFChars, GetStringUTFRegion functions is not standard UTF-8, but modified UTF-8. The null character (U+0000) and codepoints greater than or equal to U+10000 are encoded differently in modified UTF-8. Many programs actually use these functions incorrectly and treat the UTF-8 strings returned or passed into the functions as standard UTF-8 strings instead of modified UTF-8 strings. Programs should use the NewString, GetStringLength, GetStringChars, ReleaseStringChars, GetStringRegion, GetStringCritical, and ReleaseStringCritical functions, which use UTF-16LE encoding on little-endian architectures and UTF-16BE on big-endian architectures, and then use a UTF-16 to standard UTF-8 conversion routine.<br />The code is similar with Java arrays, as illustrated in the example below that takes the sum of all the elements in an array.<br /><br /><br />JNIEXPORT jint JNICALL Java_IntArray_sumArray<br />        (JNIEnv *env, jobject obj, jintArray arr) {<br />    jint buf[10];<br />    jint i, sum = 0;<br />    // This line is necessary, since Java arrays are not guaranteed<br />    // to have a continuous memory layout like C arrays.<br />    env->GetIntArrayRegion(arr, 0, 10, buf);<br />    for (i = 0; i < 10; i++) {<br />        sum += buf[i];<br />    }<br />    return sum;<br />}<br /><br />Of course, there is much more to it than this.