In a class, there can be several methods with the same name. However they must have a different signature. The signature of a method is comprised of its name, its parameter types and the order of its parameter. The signature of a method is not comprised of its return type nor its visibility nor its exceptions it may throw. The practice of defining two or more methods within the same class that shares the same names but different parameters is called overloading methods.<br />Methods with the same name in a class are called overloaded methods. Overloading methods offers no specific benefit to the JVM but it is useful to the programmer to have several methods do the same things but with different parameters. For example, we may have the operation runAroundThe represented as two methods with the same name, but different input parameter types:<br /><br /><br /><br />Code section 4.22: Method overloading.<br /><br /><br />1 public void runAroundThe(Building block) {<br />2   ...<br />3 }<br />4 <br />5 public void runAroundThe(Park park) {<br />6   ...<br />7 }<br /><br /><br /><br /><br />One type can be the subclass of the other:<br /><br /><br /><br /><br /><br /><br />Code listing 4.11: ClassName.java<br /><br /><br /> 1 public class ClassName {<br /> 2 <br /> 3   public static void sayClassName(Object aObject) {<br /> 4     System.out.println("Object");<br /> 5   }<br /> 6 <br /> 7   public static void sayClassName(String aString) {<br /> 8     System.out.println("String");<br /> 9   }<br />10 <br />11   public static void main(String[] args) {<br />12     String aString = new String();<br />13     sayClassName(aString);<br />14 <br />15     Object aObject = new String();<br />16     sayClassName(aObject);<br />17   }<br />18 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Console for Code listing 4.11<br /><br />String<br />Object<br /><br /><br /><br /><br /><br /><br />Although both methods would be fit to call the method with the String parameter, it is the method with the nearest type that will be called instead. To be more accurate, it will call the method whose parameter type is a subclass of the parameter type of the other method. So, aObject will output Object. Beware! The parameter type is defined by the declared type of an object, not its instantiated type!<br />The following two method definitions are valid<br /><br /><br /><br />Code section 4.23: Method overloading with the type order.<br /><br /><br />1 public void logIt(String param, Error err) {<br />2   ...<br />3 }<br />4 <br />5 public void logIt(Error err, String param) {<br />6   ...<br />7 }<br /><br /><br /><br /><br />because the type order is different. If both input parameters were type String, that would be a problem since the compiler would not be able to distinguish between the two:<br /><br /><br /><br />Code section 4.24: Bad method overloading.<br /><br /><br />1 public void logIt(String param, String err) {<br />2   ...<br />3 }<br />4 <br />5 public void logIt(String err, String param) {<br />6   ...<br />7 }<br /><br /><br /><br /><br />The compiler would give an error for the following method definitions as well:<br /><br /><br /><br />Code section 4.25: Another bad method overloading.<br /><br /><br />1 public void logIt(String param) {<br />2   ...<br />3 }<br />4 <br />5 public String logIt(String param) {<br />6   String retValue;<br />7   ...<br />8   return retValue;<br />9 }<br /><br /><br /><br /><br />Note, the return type is not part of the unique signature. Why not? The reason is that a method can be called without assigning its return value to a variable. This feature came from C and C++. So for the call:<br /><br /><br /><br />Code section 4.26: Ambiguous method call.<br /><br /><br />1 logIt(msg);<br /><br /><br /><br /><br />the compiler would not know which method to call. It is also the case for the thrown exceptions.<br /><br />Test your knowledge<br /><br />Question 4.6: Which methods of the Question6 class will cause compile errors?<br /><br /><br /><br />Question6.java<br /><br /><br /> 1 public class Question6 {<br /> 2  <br /> 3   public void example1() {<br /> 4   }<br /> 5 <br /> 6   public int example1() {<br /> 7   }<br /> 8 <br /> 9   public void example2(int x) {<br />10   }<br />11 <br />12   public void example2(int y) {<br />13   }<br />14 <br />15   private void example3() {<br />16   }<br />17 <br />18   public void example3() {<br />19   }<br />20 <br />21   public String example4(int x) {<br />22     return null;<br />23   }<br />24 <br />25   public String example4() {<br />26     return null;<br />27   }<br />28 }<br /><br /><br /><br /><br /><br />Answer<br /><br /><br /><br /><br />Question6.java<br /><br /><br /> 1 public class Question6 {<br /> 2  <br /> 3   public void example1() {<br /> 4   }<br /> 5 <br /> 6   public int example1() {<br /> 7   }<br /> 8 <br /> 9   public void example2(int x) {<br />10   }<br />11 <br />12   public void example2(int y) {<br />13   }<br />14 <br />15   private void example3() {<br />16   }<br />17 <br />18   public void example3() {<br />19   }<br />20 <br />21   public String example4(int x) {<br />22     return null;<br />23   }<br />24 <br />25   public String example4() {<br />26     return null;<br />27   }<br />28 }<br /><br /><br /><br /><br />The example1, example2 and example3 methods will cause compile errors. The example1 methods cannot co-exist because they have the same signature (remember, return type is not part of the signature). The example2 methods cannot co-exist because the names of the parameters are not part of the signature. The example3 methods cannot co-exist because the visibility of the methods are not part of the signature. The example4 methods can co-exist, because they have different method signatures.