NullPointerException is a RuntimeException. In Java, a special null can be assigned to an object reference. NullPointerException is thrown when an application attempts to use an object reference, having the null value. These include:<br /><br />Calling an instance method on the object referred by a null reference.<br />Accessing or modifying an instance field of the object referred by a null reference.<br />If the reference type is an array type, taking the length of a null reference.<br />If the reference type is an array type, accessing or modifying the slots of a null reference.<br />If the reference type is a subtype of Throwable, throwing a null reference.<br /><br />Applications should throw instances of this class to indicate other illegal uses of the null object.<br /><br /><br /><br />Code section 6.13: Null pointer.<br /><br /><br />1 Object obj = null;<br />2 obj.toString();  // This statement will throw a NullPointerException<br /><br /><br /><br /><br /><br />The above code shows one of the pitfall of Java, and the most common source of bugs. No object is created and the compiler does not detect it. NullPointerException is one of the most common exceptions thrown in Java.<br />Why do we need null?Edit<br />The reason we need it is because many times, we need to create an object reference before the object itself is created. Object references cannot exist without a value, so we assign the null value to it.<br /><br /><br /><br />Code section 6.14: Non-instantiated declared object.<br /><br /><br />1 public Person getPerson(boolean isWoman) {<br />2   Person person = null;<br />3   if (isWoman) {<br />4     person = createWoman();<br />5   } else {<br />6     person = createMan();<br />7   }<br />8   return person;<br />9 }<br /><br /><br /><br /><br />In the code section 6.14 we want to create the Person inside the if-else, but we also want to return the object reference to the caller, so we need to create the object reference outside of the if-else, because of the scoping rule in Java. Incorrect error-handling and poor contract design can be a pitfall with any programming language. This is also true for Java.<br />Now we will describe how to prevent NullPointerException. It does not describe general techniques for how you should program Java. It is of some use, to make you more aware of null values, and to be more careful about generating them yourself.<br />This list is not complete â€” there are no rules for preventing NullPointerException entirely in Java, because the standard libraries have to be used, and they can cause NullPointerExceptions. Also, it is possible to observe an uninitialized final field in Java, so you can't even treat a final field as being completely trusted during the object's creation.<br />A good approach is to learn how to deal with NullPointerExceptions first, and become competent with that. These suggestions will help you to cause less NullPointerExceptions, but they don't replace the need to know about NullPointerExceptions.<br />Comparing string variable with a string literalEdit<br />When you compare a variable with a string literal, most of people would do that this way:<br /><br /><br /><br />Code section 6.15: Bad comparison.<br /><br /><br />1 if (state.equals("OK")) {<br />2   ...<br />3 }<br /><br /><br /><br /><br />Always put the string literal first:<br /><br /><br /><br />Code section 6.16: Better comparison.<br /><br /><br />1 if ("OK".equals(state)) {<br />2   ...<br />3 }<br /><br /><br /><br /><br />If the state variable is null, you get a NullPointerException in the first example, but not in the second one.<br />Minimize the use of the keyword 'null' in assignment statementsEdit<br />This means not doing things like:<br /><br /><br /><br />Code section 6.17: Declaring an exception.<br /><br /><br /> 1 String s = null;<br /> 2 while (something) {<br /> 3     if (something2) {<br /> 4         s = "yep";<br /> 5     }<br /> 6 }<br /> 7 <br /> 8 if (s != null) {<br /> 9     something3(s);<br />10 }<br /><br /><br /><br /><br />You can replace this with:<br /><br /><br /><br />Code section 6.18: Declaring an exception.<br /><br /><br />1 boolean done = false;<br />2 <br />3 while (!done && something) {<br />4     if (something2) {<br />5        done = true;<br />6        something3("yep");<br />7     }<br />8 }<br /><br /><br /><br /><br />You might also consider replacing null with "" in the first example, but default values bring about bugs caused by default values being left in place. A NullPointerException is actually better, as it allows the runtime to tell you about the bug, rather than just continue with a default value.<br />Minimize the use of the new Type[int] syntax for creating arrays of objectsEdit<br />An array created using new Object[10] has 10 null pointers. That's 10 more than we want, so use collections instead, or explicitly fill the array at initialization with:<br /><br /><br /><br />Code section 6.19: Declaring an exception.<br /><br /><br />1 Object[] objects = {"blah", 5, new File("/usr/bin")};<br /><br /><br /><br /><br /><br />or:<br /><br /><br /><br />Code section 6.20: Declaring an exception.<br /><br /><br />1 Object[] objects;<br />2 objects = new Object[]{"blah", 5, new File("/usr/bin")};<br /><br /><br /><br /><br />Check all references obtained from 'untrusted' methodsEdit<br />Many methods that can return a reference can return a null reference. Make sure you check these. For example:<br /><br /><br /><br />Code section 6.21: Declaring an exception.<br /><br /><br />1 File file = new File("/etc");<br />2 File[] files = file.listFiles();<br />3 if (files != null) {<br />4     stuff<br />5 }<br /><br /><br /><br /><br />File.listFiles() can return null if /etc is not a directory.<br />You can decide to trust some methods not to return null, if you like, but that's an assumption you're making. Some methods that don't specify that they might return null, actually do, instead of throwing an exception.<br />For each loop trapEdit<br />Beware if you loop on an array or a collection in a for each loop.<br /><br /><br /><br />Code section 6.22: Visit a collection.<br /><br /><br />1 Collection<Integer> myNumbers = buildNumbers();<br />2 for (Integer myNumber : myNumbers) {<br />3   System.out.println(myNumber);<br />4 }<br /><br /><br /><br /><br />If the object is null, it does not just do zero loops, it throws a null pointer exception. So don't forget this case. Add an if statement or return empty collections:<br /><br /><br /><br />Code section 6.23: Visit a collection safety.<br /><br /><br />1 Collection<Integer> myNumbers = buildNumbers();<br />2 if (myNumbers != null) {<br />3   for (Integer myNumber : myNumbers) {<br />4     System.out.println(myNumber);<br />5   }<br />6 }<br /><br /><br /><br /><br /><br />External toolsEdit<br />There is tools like FindBugs that parse your code and warn you about potential bugs. Most of the time, it detects possible null pointers.<br /><br /><br /><br /><br /><br /><br /><br /><br />To do:<br />Add some exercises like the ones in Variables<br /><br /><br /><br /><br /><br /><br /> Unchecked Exceptions<br />Java Programming<br />Preventing NullPointerException