Sometimes, we are not only interested in mathematically correct rounded numbers, but we want that a fixed number of significant digits are always displayed, regardless of the number used. Here is an example program that returns always the correct string. You are invited to modify it such that it does the same and is simpler!<br />The constant class contains repeating constants that should exist only once in the code so that to avoid inadvertent changes. (If the one constant is changed inadvertently, it is most likely to be seen, as it is used at several locations.)<br /><br /><br /><br />Code listing 3.20: StringUtils.java<br /><br /><br /> 1 /**<br /> 2  * Class that comprises of constant values & string utilities.<br /> 3  *<br /> 4  * @since 2013-09-05<br /> 5  * @version 2014-10-14<br /> 6  */<br /> 7 public class StringUtils {<br /> 8 	/** Dash or minus constant */<br /> 9 	public static final char DASH = '-'; <br />10 	/** The exponent sign in a scientific number, or the capital letter E */<br />11 	public static final char EXPONENT = 'E';<br />12 	/** The full stop or period */<br />13 	public static final char PERIOD = '.';<br />14 	/** The zero string constant used at several places */<br />15 	public static final String ZERO = "0";<br />16 <br />17 	/**<br />18 	 * Removes all occurrences of the filter character in the text.<br />19 	 *<br />20 	 * @param text Text to be filtered<br />21 	 * @param filter The character to be removed.<br />22 	 * @return the string<br />23 	 */<br />24 	public static String filter(final String text, final String filter) {<br />25 		final String[] words = text.split("[" + filter + "]");<br />26 <br />27 		switch (words.length) {<br />28 			case 0: return text;<br />29 			case 1: return words[0];<br />30 			default:<br />31 				final StringBuilder filteredText = new StringBuilder();<br />32 <br />33 				for (final String word : words) {<br />34 					filteredText.append(word);<br />35 				}<br />36 <br />37 				return filteredText.toString();<br />38 		}<br />39 	}<br />40 }<br /><br /><br /><br /><br />The MathsUtils class is like an addition to the java.lang.Math class and contains the rounding calculations.<br /><br /><br /><br />Code listing 3.21: MathsUtils.java<br /><br /><br />  1 package string;<br />  2 <br />  3 /**<br />  4  * Class for special mathematical calculations.<br/><br />  5  * ATTENTION:<br/>Should depend only on standard Java libraries!<br />  6  *<br />  7  * @since 2013-09-05<br />  8  * @version 2014-10-14<br />  9 */<br /> 10 public class MathsUtils {<br /> 11 <br /> 12 	// CONSTANTS<br /> 13 	// ------------------------------------------<br /> 14 <br /> 15 	/** The exponent sign in a scientific number, or the capital letter E. */<br /> 16 	public static final char EXPONENT = 'E';<br /> 17 <br /> 18 	/** Value after which the language switches from scientific to double */<br /> 19 	private static final double E_TO_DOUBLE = 1E-3;<br /> 20 <br /> 21 	/** The zero string constant used at several places. */<br /> 22 	public static final String ZERO = "0";<br /> 23 <br /> 24 	/** The string of zeros */<br /> 25 	private static final String ZEROS = "000000000000000000000000000000000";<br /> 26 <br /> 27 	// METHODS<br /> 28 	// ------------------------------------------<br /> 29 <br /> 30 	/**<br /> 31 	 * Determines, if the number uses a scientific representation.<br /> 32 	 *<br /> 33 	 * @param number the number<br /> 34 	 * @return true, if it is a scientific number, false otherwise<br /> 35 	 */<br /> 36 	private static boolean isScientific(final double number) {<br /> 37 		return ((new Double(number)).toString().indexOf(EXPONENT) > 0);<br /> 38 	}<br /> 39 <br /> 40 	/**<br /> 41 	 * Determines how many zeros are to be appended after the decimal digits.<br /> 42 	 *<br /> 43 	 * @param significantsAfter Requested significant digits after decimal<br /> 44 	 * @param separator Language-specific decimal separator<br /> 45 	 * @param number Rounded number<br /> 46 	 * @return Requested value<br /> 47 	 */<br /> 48 	private static byte calculateMissingSignificantZeros(<br /> 49 			final byte significantsAfter,<br /> 50 			final char separator,<br /> 51 			final double number) {<br /> 52 <br /> 53 		final byte after = findSignificantsAfterDecimal(separator, number);<br /> 54 <br /> 55 		final byte zeros =<br /> 56 				(byte) (significantsAfter - ((after == 0) ? 1 : after));<br /> 57 <br /> 58 		return ((zeros >= 0) ? zeros : 0);<br /> 59 	}<br /> 60 <br /> 61 	/**<br /> 62 	 * Finds the insignificant zeros after the decimal separator.<br /> 63 	 *<br /> 64 	 * @param separator Language-specific decimal separator<br /> 65 	 * @param number the number<br /> 66 	 * @return the byte<br /> 67 	 */<br /> 68 	private static byte findInsignificantZerosAfterDecimal(<br /> 69 			final char separator,<br /> 70 			final double number) {<br /> 71 <br /> 72 		if ((Math.abs(number) >= 1) || isScientific(number)) {<br /> 73 			return 0;<br /> 74 		} else {<br /> 75 			final StringBuilder string = new StringBuilder();<br /> 76 <br /> 77 			string.append(number);<br /> 78 			string.delete(0,<br /> 79 					string.indexOf(new Character(separator).toString()) + 1);<br /> 80 <br /> 81 			// Determine what to match:<br /> 82 			final String regularExpression = "[1-9]";<br /> 83 <br /> 84 			final String[] split = string.toString().split(regularExpression);<br /> 85 <br /> 86 			return (split.length > 0) ? (byte) split[0].length() : 0;<br /> 87 		}<br /> 88 	}<br /> 89 <br /> 90 	/**<br /> 91 	 * Calculates the number of all significant digits (without the sign and<br /> 92 	 * the decimal separator).<br /> 93 	 *<br /> 94 	 * @param significantsAfter Requested significant digits after decimal<br /> 95 	 * @param separator Language-specific decimal separator<br /> 96 	 * @param number Value where the digits are to be counted<br /> 97 	 * @return Number of significant digits<br /> 98 	 */<br /> 99 	private static byte findSignificantDigits(final byte significantsAfter,<br />100 			final char separator,<br />101 			final double number) {<br />102 <br />103 		if (number == 0) { return 0; }<br />104 		else {<br />105 			String mantissa =<br />106 					findMantissa(separator, new Double(number).toString());<br />107 <br />108 			if (number == (long)number) {<br />109 				mantissa = mantissa.substring(0, mantissa.length() - 1);<br />110 			}<br />111 <br />112 			mantissa = retrieveDigits(separator, mantissa);<br />113 			// Find the position of the first non-zero digit:<br />114 			short nonZeroAt = 0;<br />115 <br />116 			for (; (nonZeroAt < mantissa.length())<br />117 					&& (mantissa.charAt(nonZeroAt) == '0'); nonZeroAt++) ;<br />118 <br />119 			return (byte)mantissa.substring(nonZeroAt).length();<br />120 		}<br />121 	}<br />122 	<br />123 	/**<br />124 	 * Determines the number of significant digits after the decimal separator<br />125 	 * knowing the total number of significant digits and the number before the<br />126 	 * decimal separator.<br />127 	 *<br />128 	 * @param significantsBefore Number of significant digits before separator<br />129 	 * @param significantDigits Number of all significant digits<br />130 	 * @return Number of significant decimals after the separator<br />131 	 */<br />132 	private static byte findSignificantsAfterDecimal(<br />133 			final byte significantsBefore,<br />134 			final byte significantDigits) {<br />135 <br />136 		final byte afterDecimal =<br />137 				(byte) (significantDigits - significantsBefore);<br />138 <br />139 		return (byte) ((afterDecimal > 0) ? afterDecimal : 0);<br />140 	}<br />141 <br />142 	/**<br />143 	 * Determines the number of digits before the decimal point.<br />144 	 *<br />145 	 * @param separator Language-specific decimal separator<br />146 	 * @param number Value to be scrutinised<br />147 	 * @return Number of digits before the decimal separator<br />148 	 */<br />149 	private static byte findSignificantsBeforeDecimal(final char separator,<br />150 													final double number) {<br />151 <br />152 		final String value = new Double(number).toString();<br />153 <br />154 		// Return immediately, if result is clear: Special handling at<br />155 		// crossroads of floating point and exponential numbers:<br />156 		if ((number == 0) || (Math.abs(number) >= E_TO_DOUBLE)<br />157 				&& (Math.abs(number) < 1)) {<br />158 <br />159 			return 0;<br />160 		} else if ((Math.abs(number) > 0) && (Math.abs(number) < E_TO_DOUBLE)) {<br />161 			return 1;<br />162 		} else {<br />163 			byte significants = 0;<br />164 			// Significant digits to the right of decimal separator:<br />165 			for (byte b = 0; b < value.length(); b++) {<br />166 				if (value.charAt(b) == separator) {<br />167 					break;<br />168 				} else if (value.charAt(b) != StringUtils.DASH) {<br />169 					significants++;<br />170 				}<br />171 			}<br />172 <br />173 			return significants;<br />174 		}<br />175 	}<br />176 <br />177 	/**<br />178 	 * Returns the exponent part of the double number.<br />179 	 *<br />180 	 * @param number Value of which the exponent is of interest<br />181 	 * @return Exponent of the number or zero.<br />182 	 */<br />183 	private static short findExponent(final double number) {<br />184 		return new Short(findExponent((new Double(number)).toString()));<br />185 	}<br />186 <br />187 	/**<br />188 	 * Finds the exponent of a number.<br />189 	 *<br />190 	 * @param value Value where an exponent is to be searched<br />191 	 * @return Exponent, if it exists, or "0".<br />192 	 */<br />193 	private static String findExponent(final String value) {<br />194 		final short exponentAt = (short) value.indexOf(EXPONENT);<br />195 <br />196 		if (exponentAt < 0) { return ZERO; }<br />197 		else {<br />198 			return value.substring(exponentAt + 1);<br />199 		}<br />200 	}<br />201 <br />202 	/**<br />203 	 * Finds the mantissa of a number.<br />204 	 *<br />205 	 * @param separator Language-specific decimal separator<br />206 	 * @param value Value where the mantissa is to be found<br />207 	 * @return Mantissa of the number<br />208 	 */<br />209 	private static String findMantissa(final char separator,<br />210 										final String value) {<br />211 <br />212 		String strValue = value;<br />213 <br />214 		final short exponentAt = (short) strValue.indexOf(EXPONENT);<br />215 <br />216 		if (exponentAt > -1) {<br />217 			strValue = strValue.substring(0, exponentAt);<br />218 		}<br />219 		return strValue;<br />220 	}<br />221 <br />222 	/**<br />223 	 * Retrieves the digits of the value without decimal separator or sign.<br />224 	 *<br />225 	 * @param separator<br />226 	 * @param number Mantissa to be scrutinised<br />227 	 * @return The digits only<br />228 	 */<br />229 	private static String retrieveDigits(final char separator, String number) {<br />230 		// Strip off exponent part, if it exists:<br />231 		short eAt = (short)number.indexOf(EXPONENT);<br />232 <br />233 		if (eAt > -1) {<br />234 			number = number.substring(0, eAt);<br />235 		}<br />236 <br />237 		return number.replace((new Character(StringUtils.DASH)).toString(), "").<br />238 				replace((new Character(separator)).toString(), "");<br />239 	}<br />240 <br />241 <br />242 	// ---- Public methods ----------------------<br />243 <br />244 	/**<br />245 	 * Returns the number of digits in the long value.<br />246 	 *<br />247 	 * @param value the value<br />248 	 * @return the byte<br />249 	 */<br />250 	public static byte digits(final long value) {<br />251 		return (byte) StringUtils.filter(Long.toString(value), ".,").length();<br />252 	}<br />253 <br />254 	/**<br />255 	 * Finds the significant digits after the decimal separator of a mantissa.<br />256 	 *<br />257 	 * @param separator Language-specific decimal separator<br />258 	 * @param number Value to be scrutinised<br />259 	 * @return Number of significant zeros after decimal separator.<br />260 	 */<br />261 	public static byte findSignificantsAfterDecimal(final char separator,<br />262 													final double number) {<br />263 <br />264 		if (number == 0) { return 1; }<br />265 		else {<br />266 			String value = (new Double(number)).toString();<br />267 <br />268 			final short separatorAt = (short) value.indexOf(separator);<br />269 <br />270 			if (separatorAt > -1) {<br />271 				value = value.substring(separatorAt + 1);<br />272 			}<br />273 <br />274 			final short exponentAt = (short) value.indexOf(EXPONENT);<br />275 <br />276 			if (exponentAt > 0) {<br />277 				value = value.substring(0, exponentAt);<br />278 			}<br />279 <br />280 			final Long longValue = new Long(value).longValue();<br />281 <br />282 			if (Math.abs(number) < 1) {<br />283 				return (byte) longValue.toString().length();<br />284 			} else if (longValue == 0) {<br />285 				return 0;<br />286 			} else {<br />287 				return (byte) (("0." + value).length() - 2);<br />288 			}<br />289 		}<br />290 	}<br />291 <br />292 	/**<br />293 	 * Calculates the power of the base to the exponent without changing the<br />294 	 * least-significant digits of a number.<br />295 	 *<br />296 	 * @param basis<br />297 	 * @param exponent<br />298 	 * @return basis to power of exponent<br />299 	 */<br />300 	public static double power(final int basis, final short exponent) {<br />301 		return power((short) basis, exponent);<br />302 	}<br />303 <br />304 	/**<br />305 	 * Calculates the power of the base to the exponent without changing the<br />306 	 * least-significant digits of a number.<br />307 	 *<br />308 	 * @param basis the basis<br />309 	 * @param exponent the exponent<br />310 	 * @return basis to power of exponent<br />311 	 */<br />312 	public static double power(final short basis, final short exponent) {<br />313 		if (basis == 0) {<br />314 			return (exponent != 0) ? 1 : 0;<br />315 		} else {<br />316 			if (exponent == 0) {<br />317 				return 1;<br />318 			} else {<br />319 				// The Math method power does change the least significant<br />320 				// digits after the decimal separator and is therefore useless.<br />321 				double result = 1;<br />322 				short s = 0;<br />323 <br />324 				if (exponent > 0) {<br />325 					for (; s < exponent; s++) {<br />326 						result *= basis;<br />327 					}<br />328 				} else if (exponent < 0) {<br />329 					for (s = exponent; s < 0; s++) {<br />330 						result /= basis;<br />331 					}<br />332 				}<br />333 <br />334 				return result;<br />335 			}<br />336 		}<br />337 	}<br />338 <br />339 	/**<br />340 	 * Rounds a number to the decimal places.<br />341 	 *<br />342 	 * @param significantsAfter Requested significant digits after decimal<br />343 	 * @param separator Language-specific decimal separator<br />344 	 * @param number Number to be rounded<br />345 	 * @return Rounded number to the requested decimal places<br />346 	 */<br />347 	public static double round(final byte significantsAfter,<br />348 								final char separator,<br />349 								final double number) {<br />350 <br />351 		if (number == 0) { return 0; }<br />352 		else {<br />353 			final double constant = power(10, (short)<br />354 					(findInsignificantZerosAfterDecimal(separator, number)<br />355 							+ significantsAfter));<br />356 			final short dExponent = findExponent(number);<br />357 <br />358 			short exponent = dExponent;<br />359 <br />360 			double value = number*constant*Math.pow(10, -exponent);<br />361 			final String exponentSign =<br />362 					(exponent < 0) ? String.valueOf(StringUtils.DASH) : "";<br />363 <br />364 			if (exponent != 0) {<br />365 				exponent = (short) Math.abs(exponent);<br />366 <br />367 				value = round(value);<br />368 			} else {<br />369 				value = round(value)/constant;<br />370 			}<br />371 <br />372 			// Power method cannot be used, as the exponentiated number may<br />373 			// exceed the maximal long value.<br />374 			exponent -= Math.signum(dExponent)*(findSignificantDigits<br />375 					(significantsAfter, separator, value) - 1);<br />376 <br />377 			if (dExponent != 0) {<br />378 				String strValue = Double.toString(value);<br />379 <br />380 				strValue = strValue.substring(0, strValue.indexOf(separator))<br />381 						+ EXPONENT + exponentSign + Short.toString(exponent);<br />382 <br />383 				value = new Double(strValue);<br />384 			}<br />385 <br />386 			return value;<br />387 		}<br />388 	}<br />389 <br />390 	/**<br />391 	 * Rounds a number according to mathematical rules.<br />392 	 *<br />393 	 * @param value the value<br />394 	 * @return the double<br />395 	 */<br />396 	public static double round(final double value) {<br />397 		return (long) (value + .5);<br />398 	}<br />399 <br />400 	/**<br />401 	 * Rounds to a fixed number of significant digits.<br />402 	 *<br />403 	 * @param significantDigits Requested number of significant digits<br />404 	 * @param separator Language-specific decimal separator<br />405 	 * @param dNumber Number to be rounded<br />406 	 * @return Rounded number<br />407 	 */<br />408 	public static String roundToString(final byte significantDigits,<br />409 										final char separator,<br />410 										double dNumber) {<br />411 										<br />412 		// Number of significants that *are* before the decimal separator:<br />413 		final byte significantsBefore =<br />414 			findSignificantsBeforeDecimal(separator, dNumber);<br />415 		// Number of decimals that *should* be after the decimal separator:<br />416 		final byte significantsAfter = findSignificantsAfterDecimal(<br />417 				significantsBefore, significantDigits);<br />418 		// Round to the specified number of digits after decimal separator:<br />419 		final double rounded = MathsUtils.round(significantsAfter, separator, dNumber);<br />420 <br />421 		final String exponent = findExponent((new Double(rounded)).toString());<br />422 		final String mantissa = findMantissa(separator,<br />423 						(new Double(rounded)).toString());<br />424 <br />425 		final double dMantissa = new Double(mantissa).doubleValue();<br />426 		final StringBuilder result = new StringBuilder(mantissa);<br />427 		// Determine the significant digits in this number:<br />428 		final byte significants = findSignificantDigits(significantsAfter,<br />429 				separator, dMantissa);<br />430 		// Add lagging zeros, if necessary:<br />431 		if (significants <= significantDigits) {<br />432 			if (significantsAfter != 0) {<br />433 				result.append(ZEROS.substring(0,<br />434 						calculateMissingSignificantZeros(significantsAfter,<br />435 								separator, dMantissa)));<br />436 			} else {<br />437 				// Cut off the decimal separator & after decimal digits:<br />438 				final short decimal = (short) result.indexOf(<br />439 						new Character(separator).toString());<br />440 <br />441 				if (decimal > -1) {<br />442 					result.setLength(decimal);<br />443 				}<br />444 			}<br />445 		} else if (significantsBefore > significantDigits) {<br />446 			dNumber /= power(10, (short) (significantsBefore - significantDigits));<br />447 <br />448 			dNumber = round(dNumber);<br />449 <br />450 			final short digits =<br />451 					(short) (significantDigits + ((dNumber < 0) ? 1 : 0));<br />452 <br />453 			final String strDouble = (new Double(dNumber)).toString().substring(0, digits);<br />454 <br />455 			result.setLength(0);<br />456 			result.append(strDouble + ZEROS.substring(0,<br />457 					significantsBefore - significantDigits));<br />458 		}<br />459 <br />460 		if (new Short(exponent) != 0) {<br />461 			result.append(EXPONENT + exponent);<br />462 		}<br />463 <br />464 		return result.toString();<br />465 	} // public static String roundToString(…)<br />466 <br />467 	/**<br />468 	 * Rounds to a fixed number of significant digits.<br />469 	 *<br />470 	 * @param separator Language-specific decimal separator<br />471 	 * @param significantDigits Requested number of significant digits<br />472 	 * @param value Number to be rounded<br />473 	 * @return Rounded number<br />474 	 */<br />475 	public static String roundToString(final char separator,<br />476 										final int significantDigits,<br />477 										float value) {<br />478 <br />479 		return roundToString((byte)significantDigits, separator,<br />480 				(double)value);<br />481 	}<br />482 } // class MathsUtils<br /><br /><br /><br /><br />The code is tested with the following JUnit test:<br /><br /><br /><br />Code listing 3.22: MathsUtilsTest.java<br /><br /><br />  1 package string;<br />  2 <br />  3 import static org.junit.Assert.assertEquals;<br />  4 import static org.junit.Assert.assertFalse;<br />  5 import static org.junit.Assert.assertTrue;<br />  6 <br />  7 import java.util.Vector;<br />  8 <br />  9 import org.junit.Test;<br /> 10 <br /> 11 /**<br /> 12  * The JUnit test for the <code>MathsUtils</code> class.<br /> 13  *<br /> 14  * @since 2013-03-26<br /> 15  * @version 2014-10-14<br /> 16  */<br /> 17 public class MathsUtilsTest {<br /> 18 <br /> 19 	/**<br /> 20 	 * Method that adds a negative and a positive value to values.<br /> 21 	 *<br /> 22 	 * @param d the double value<br /> 23 	 * @param values the values<br /> 24 	 */<br /> 25 	private static void addValue(final double d, Vector<Double> values) {<br /> 26 		values.add(-d);<br /> 27 		values.add(d);<br /> 28 	}<br /> 29 <br /> 30 	// Public methods ------<br /> 31 <br /> 32 	/**<br /> 33 	 * Tests the round method with a double parameter.<br /> 34 	 */<br /> 35 	@Test<br /> 36 	public void testRoundToStringDoubleByteCharDouble() {<br /> 37 		// Test rounding<br /> 38 		final Vector<Double> values = new Vector<Double>();<br /> 39 		final Vector<String> strValues = new Vector<String>();<br /> 40 <br /> 41 		values.add(0.0);<br /> 42 		strValues.add("0.00000");<br /> 43 		addValue(1.4012984643248202e-45, values);<br /> 44 		strValues.add("-1.4012E-45");<br /> 45 		strValues.add("1.4013E-45");<br /> 46 		addValue(1.999999757e-5, values);<br /> 47 		strValues.add("-1.9999E-5");<br /> 48 		strValues.add("2.0000E-5");<br /> 49 		addValue(1.999999757e-4, values);<br /> 50 		strValues.add("-1.9999E-4");<br /> 51 		strValues.add("2.0000E-4");<br /> 52 		addValue(1.999999757e-3, values);<br /> 53 		strValues.add("-0.0019999");<br /> 54 		strValues.add("0.0020000");<br /> 55 		addValue(0.000640589, values);<br /> 56 		strValues.add("-6.4058E-4");<br /> 57 		strValues.add("6.4059E-4");<br /> 58 		addValue(0.3396899998188019, values);<br /> 59 		strValues.add("-0.33968");<br /> 60 		strValues.add("0.33969");<br /> 61 		addValue(0.34, values);<br /> 62 		strValues.add("-0.33999");<br /> 63 		strValues.add("0.34000");<br /> 64 		addValue(7.07, values);<br /> 65 		strValues.add("-7.0699");<br /> 66 		strValues.add("7.0700");<br /> 67 		addValue(118.188, values);<br /> 68 		strValues.add("-118.18");<br /> 69 		strValues.add("118.19");<br /> 70 		addValue(118.2, values);<br /> 71 		strValues.add("-118.19");<br /> 72 		strValues.add("118.20");<br /> 73 		addValue(123.405009, values);<br /> 74 		strValues.add("-123.40");<br /> 75 		strValues.add("123.41");<br /> 76 		addValue(30.76994323730469, values);<br /> 77 		strValues.add("-30.769");<br /> 78 		strValues.add("30.770");<br /> 79 		addValue(130.76994323730469, values);<br /> 80 		strValues.add("-130.76");<br /> 81 		strValues.add("130.77");<br /> 82 		addValue(540, values);<br /> 83 		strValues.add("-539.99");<br /> 84 		strValues.add("540.00");<br /> 85 		addValue(12345, values);<br /> 86 		strValues.add("-12344");<br /> 87 		strValues.add("12345");<br /> 88 		addValue(123456, values);<br /> 89 		strValues.add("-123450");<br /> 90 		strValues.add("123460");<br /> 91 		addValue(540911, values);<br /> 92 		strValues.add("-540900");<br /> 93 		strValues.add("540910");<br /> 94 		addValue(9.223372036854776e56, values);<br /> 95 		strValues.add("-9.2233E56");<br /> 96 		strValues.add("9.2234E56");<br /> 97 <br /> 98 		byte i = 0;<br /> 99 		final byte significants = 5;<br />100 <br />101 		for (final double element : values) {<br />102 			final String strValue;<br />103 <br />104 			try {<br />105 				strValue = MathsUtils.roundToString(significants, StringUtils.PERIOD, element);<br />106 <br />107 				System.out.println(" MathsUtils.round(" + significants  + ", '"<br />108 						+ StringUtils.PERIOD + "', " + element + ") ==> "<br />109 						+ strValue + " = " + strValues.get(i));<br />110 				assertEquals("Testing roundToString", strValue, strValues.get(i++));<br />111 			} catch (final Exception e) {<br />112 				// TODO Auto-generated catch block<br />113 				e.printStackTrace();<br />114 			}<br />115 		}<br />116 	}<br />117 <br />118 }	// class MathsUtilsTest<br /><br /><br /><br /><br />The output of the JUnit test follows:<br /><br /><br /><br />Output for code listing 3.22<br /><br /> MathsUtils.round(5, '.', 0.0) ==> 0.00000 = 0.00000<br /> MathsUtils.round(5, '.', -1.4012984643248202E-45) ==> -1.4012E-45 = -1.4012E-45<br /> MathsUtils.round(5, '.', 1.4012984643248202E-45) ==> 1.4013E-45 = 1.4013E-45<br /> MathsUtils.round(5, '.', -1.999999757E-5) ==> -1.9999E-5 = -1.9999E-5<br /> MathsUtils.round(5, '.', 1.999999757E-5) ==> 2.0000E-5 = 2.0000E-5<br /> MathsUtils.round(5, '.', -1.999999757E-4) ==> -1.9999E-4 = -1.9999E-4<br /> MathsUtils.round(5, '.', 1.999999757E-4) ==> 2.0000E-4 = 2.0000E-4<br /> MathsUtils.round(5, '.', -0.001999999757) ==> -0.0019999 = -0.0019999<br /> MathsUtils.round(5, '.', 0.001999999757) ==> 0.0020000 = 0.0020000<br /> MathsUtils.round(5, '.', -6.40589E-4) ==> -6.4058E-4 = -6.4058E-4<br /> MathsUtils.round(5, '.', 6.40589E-4) ==> 6.4059E-4 = 6.4059E-4<br /> MathsUtils.round(5, '.', -0.3396899998188019) ==> -0.33968 = -0.33968<br /> MathsUtils.round(5, '.', 0.3396899998188019) ==> 0.33969 = 0.33969<br /> MathsUtils.round(5, '.', -0.34) ==> -0.33999 = -0.33999<br /> MathsUtils.round(5, '.', 0.34) ==> 0.34000 = 0.34000<br /> MathsUtils.round(5, '.', -7.07) ==> -7.0699 = -7.0699<br /> MathsUtils.round(5, '.', 7.07) ==> 7.0700 = 7.0700<br /> MathsUtils.round(5, '.', -118.188) ==> -118.18 = -118.18<br /> MathsUtils.round(5, '.', 118.188) ==> 118.19 = 118.19<br /> MathsUtils.round(5, '.', -118.2) ==> -118.19 = -118.19<br /> MathsUtils.round(5, '.', 118.2) ==> 118.20 = 118.20<br /> MathsUtils.round(5, '.', -123.405009) ==> -123.40 = -123.40<br /> MathsUtils.round(5, '.', 123.405009) ==> 123.41 = 123.41<br /> MathsUtils.round(5, '.', -30.76994323730469) ==> -30.769 = -30.769<br /> MathsUtils.round(5, '.', 30.76994323730469) ==> 30.770 = 30.770<br /> MathsUtils.round(5, '.', -130.7699432373047) ==> -130.76 = -130.76<br /> MathsUtils.round(5, '.', 130.7699432373047) ==> 130.77 = 130.77<br /> MathsUtils.round(5, '.', -540.0) ==> -539.99 = -539.99<br /> MathsUtils.round(5, '.', 540.0) ==> 540.00 = 540.00<br /> MathsUtils.round(5, '.', -12345.0) ==> -12344 = -12344<br /> MathsUtils.round(5, '.', 12345.0) ==> 12345 = 12345<br /> MathsUtils.round(5, '.', -123456.0) ==> -123450 = -123450<br /> MathsUtils.round(5, '.', 123456.0) ==> 123460 = 123460<br /> MathsUtils.round(5, '.', -540911.0) ==> -540900 = -540900<br /> MathsUtils.round(5, '.', 540911.0) ==> 540910 = 540910<br /> MathsUtils.round(5, '.', -9.223372036854776E56) ==> -9.2233E56 = -9.2233E56<br /> MathsUtils.round(5, '.', 9.223372036854776E56) ==> 9.2234E56 = 9.2234E56<br /><br /><br /><br />If you are interested in a comparison with C#, take a look at the rounding number example there. If you are interested in a comparison with C++, you can compare this code here with the same example over there.<br />Notice that in the expression starting with if ((D == 0), I have to use OR instead of the || because of a bug in the source template.<br /><br /><br /><br /><br /><br /><br /><br />To do:<br />Add some exercises like the ones in Variables<br /><br /><br /><br /><br /><br /><br /> Arrays<br />Java Programming<br />Mathematical functions<br />Large numbers