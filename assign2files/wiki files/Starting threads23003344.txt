Now, that we know how to effectively create a Runnable process block and a Thread object that executes it, we need to understand how to start the created Thread objects. This couldn't be simpler. For this process, we will be calling the start() method on the Thread objects and voilà, our threads will begin executing their individual process tasks.<br /><br /><br /><br />Code listing 3: Starting the Thread objects<br /><br /><br />public class ThreadLogic {<br />    public static void main(String[] args) {<br />        Thread t1 = new Thread(new RunnableProcess("Thread-1"));<br />        Thread t2 = new Thread(new RunnableProcess("Thread-2"));<br />        Thread t3 = new Thread(new RunnableProcess("Thread-3"));<br /><br />        t1.start();<br />        t2.start();<br />        t3.start();<br />    }<br />}<br /><br /><br /><br /><br />The above code will start all three declared threads. This way, all three threads will begin their execution one-by-one. However, this being concurrent programming and us having declared random times for the halting of the execution, the outputs for every one of us would differ. Following is the output we received when we executed the above program.<br /><br /><br /><br />Output for code listing 3<br /><br />Thread-1 is sleeping for 419<br />Thread-3 is sleeping for 876<br />Thread-2 is sleeping for 189<br />Thread-2 is done<br />Thread-1 is done<br />Thread-3 is done<br /><br /><br /><br />It should be noted that the execution of the Thread didn't occur in the desired order. Instead of the order t1–t2–t3, the threads executed in the order of t1–t3–t2. The order in which the threads are executed is completely dependant on the operating system and may change for every execution of the program, thus making output of multithreaded application difficult to predict and control. Some people suggest that this is the major reason that adds to the complexity of multithreaded programming and its debugging. However, it should be observed that once the threads were put to sleep using the Thread.sleep(...) function, the execution intervals and order can be predicted quite capably. The thread with the least amount of sleeping time was t2 ("Thread-2") with 189 milliseconds of sleep hence it got called first. Then t1 was called and finally t3 was called.