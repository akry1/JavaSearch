The advantage of the unbounded wildcard (i.e. <?>) compared to a raw type (i.e. without generic) is to explicitly say that the parameterized type is unknown, not any type. That way, all the operations that implies to know the type are forbidden to avoid unsafe operation. Consider the following code:<br /><br /><br /><br />Code section 4.45: Unsafe operation.<br /><br /><br />1 public void addAtBottom(Collection anyCollection) {<br />2   anyCollection.add(new Integer(1));<br />3 }<br /><br /><br /><br /><br />This code will compile but this code may corrupt the collection if the collection only contains strings:<br /><br /><br /><br /><br /><br /><br />Code section 4.46: Corruption of list.<br /><br /><br />1 List<String> col = new ArrayList<String>();<br />2 addAtBottom(col);<br />3 col.get(0).endsWith(".");<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Console for Code section 4.46<br /><br />Exception in thread "main" java.lang.ClassCastException: java.lang.Integer incompatible with java.lang.String<br />at Example.main(Example.java:17)<br /><br /><br /><br /><br /><br /><br />This situation could have been avoided if the addAtBottom(Collection) method was defined with an unbounded wildcard: addAtBottom(Collection<?>). With this signature, it is impossible to compile a code that is dependent of the parameterized type. Only independent methods of a collection (clear(), isEmpty(), iterator(), remove(Object o), size(), ...) can be called. For instance, addAtBottom(Collection<?>) could contain the following code:<br /><br /><br /><br />Code section 4.47: Safe operation.<br /><br /><br />1 public void addAtBottom(Collection<?> anyCollection) {<br />2    Iterator<?> iterator = anyCollection.iterator();<br />3    while (iterator.hasNext()) {<br />4       System.out.print(iterator.next());<br />5    }<br />6 }