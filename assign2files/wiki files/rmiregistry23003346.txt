Remote objects can be listed in the RMI Registry. Clients can get a reference to the remote object by querying the Registry. After that, the client can call methods on the remote objects. (Remote object references can also be acquired by calling other remote methods. The Registry is really a 'bootstrap' that solves the problem of where to get the initial remote reference from.)<br />The RMI Registry can either be started within the server JVM, via the LocateRegistry.createRegistry() API, or a separate process called rmiregistry that has to be started before remote objects can be added to it, e.g. by the command line in Unix:<br /><br /><br /><br />rmiregistry on Unix<br /><br />rmiregistry <port> &<br /><br /><br /><br />or under Windows:<br /><br /><br /><br />rmiregistry on Windows<br /><br />start rmiregistry <port><br /><br /><br /><br />If port is not specified the default 1099 is used. The client will need to connect to this port to access the Registry.<br />The Registry can also be started from a program by calling the following code:<br /><br /><br /><br />Code section 1: rmiregistry starting<br /><br /><br />import java.rmi.registry.LocateRegistry;<br />...<br />Registry reg = LocateRegistry.createRegistry(iPort);<br /><br /><br /><br /><br />Objects passed in as parameters to the remote objects's methods will be passed by value. If the remote object changes the passed-in object values, it won't be reflected on the client side, this is opposite what happens when a local object is called. Objects that used as parameters for remote methods invocation must implement the java.io.Serializable interface, as they are going to be serialized when passed through the network, and a new object will be created on the other side.<br />However, exported remote objects passed as parameters are passed by remote reference.