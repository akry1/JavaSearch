result
"{""result"":[""A constructor is called to initialize an object immediately after the object has been allocated:<br /><br /><br /><br />Code listing 4.3: Cheese.java<br /><br /><br />1 public class Cheese {<br />2   // This is a constructor<br />3   public Cheese() {<br />4     System.out.println(\""Construct an instance\"");<br />5   }<br />6 }<br /><br /><br /><br /><br />Typically, a constructor is invoked using the new keyword:<br /><br /><br /><br />Code section 4.1: A constructor call.<br /><br /><br />1 Cheese cheese = new Cheese();<br /><br /><br /><br /><br />The constructor syntax is close to the method syntax. However, the constructor has the same name as the name of the class (with the same case) and the constructor has no return type. The second point is the most important difference as a method can also have the same name as the class, which is not recommended:<br /><br /><br /><br />Code listing 4.4: Cheese.java<br /><br /><br />1 public class Cheese {<br />2   // This is a method with the same name as the class<br />3   public void Cheese() {<br />4     System.out.println(\""A method execution.\"");<br />5   }<br />6 }<br /><br /><br /><br /><br />The returned object is always a valid, meaningful object, as opposed to relying on a separate initialization method. A constructor cannot be abstract, final, native, static, strictfp nor synchronized. However, a constructor, like methods, can be overloaded and take parameters.<br /><br /><br /><br />Code listing 4.5: Cheese.java<br /><br /><br /> 1 public class Cheese {<br /> 2      // This is a constructor<br /> 3      public Cheese() {<br /> 4           doStuff();<br /> 5      }<br /> 6 <br /> 7      // This is another constructor<br /> 8      public Cheese(int weight) {<br /> 9           doStuff();<br />10      }<br />11 <br />12      // This is yet another constructor<br />13      public Cheese(String type, int weight) {<br />14           doStuff();<br />15      }<br />16 }<br /><br /><br /><br /><br />By convention, a constructor that accepts an object of its own type as a parameter and copies the data members is called a copy constructor. One interesting feature of constructors is that if and only if you do not specify a constructor in your class, the compiler will create one for you. This default constructor, if written out would look like:<br /><br /><br /><br />Code listing 4.6: Cheese.java<br /><br /><br />1 public class Cheese {<br />2      public Cheese() {<br />3            super();<br />4      }<br />5 }<br /><br /><br /><br /><br />The super() command calls the constructor of the superclass. If there is no explicit call to super(...) or this(...), then the default superclass constructor super(); is called before the body of the constructor is executed. That said, there are instances where you need to add in the call manually. For example, if you write even one constructor, no matter what parameters it takes, the compiler will not add a default constructor. The code listing 4.8 results in a runtime error:<br /><br /><br /><br />Code listing 4.7: Cheese.java<br /><br /><br />1 public class Cheese {<br />2      public Cheese(int weight, String type) {<br />3           doStuff();<br />4      }<br />5 }<br /><br /><br /><br /><br /><br /><br /><br />Code listing 4.8: Mouse.java<br /><br /><br />1 public class Mouse {<br />2      public void eatCheese() {<br />3              Cheese c = new Cheese(); // Oops, compile time error!<br />4      }<br />5 }<br /><br /><br /><br /><br />This is something to keep in mind when extending existing classes. Either make a default constructor, or make sure every class that inherits your class uses the correct constructor.<br />"",""In order to get from class to object, we \""build\"" our object by instantiation. Instantiation simply means to create an instance of a class. Instance and object are very similar terms and are sometimes interchangeable, but remember that an instance refers to a specific object, which was created from a class.<br />This instantiation is brought about by one of the class's methods, called a constructor. As its name implies, a constructor builds the object based on the blueprint. Behind the scenes, this means that computer memory is being allocated for the instance, and values are being assigned to the data members.<br />In general there are four constructor types: default, non-default, copy, and cloning.<br />A default constructor will build the most basic instance. Generally, this means assigning all the fields values like null, zero, or an empty string. Nothing would stop you, however, from your default sports car color from being red, but this is generally bad programming style. Another programmer would be confused if your basic car came out red instead of say, colorless.<br /><br /><br /><br />Code section 3.79: A default constructor.<br /><br /><br />1 SportsCar car = new SportsCar();<br /><br /><br /><br /><br />A non-default constructor is designed to create an object instance with prescribed values for most, if not all, of the object's fields. The car is red, goes from 0-60 in 12 seconds, tops out at 190mph, etc.<br /><br /><br /><br />Code section 3.80: A non-default constructor.<br /><br /><br />1 SportsCar car = new SportsCar(\""red\"", 12, 190);<br /><br /><br /><br /><br />A copy constructor is not included in the Java language, however one can easily create a constructor that do the same as a copy constructor. It's important to understand what it is. As the name implies, a copy constructor creates a new instance to be a duplicate of an already existing one. In Java, this can be also accomplished by creating the instance with the default constructor, and then using the assignment operator to equivocate them. This is not possible in all languages though, so just keep the terminology under your belt.<br />Java has the concepts of cloning object, and the end results are similar to copy constructor. Cloning an object is faster than creation with the new keyword, because all the object memory is copied at once to destination cloned object. This is possible by implementing the Cloneable interface, which allows the method Object.clone() to perform a field-by-field copy.<br /><br /><br /><br />Code section 3.81: Cloning object.<br /><br /><br />1 SportsCar car = oldCar.clone();<br />"",""A constructor is a special method in a class which is used to construct an instance of the class. The constructor can perform initialization for the object, beyond that which the Java VM does automatically. For example, Java will automatically initialize the fields point0 and point1 to null.<br /><br /><br /><br />Code section 2.4: The constructor for the class<br /><br /><br />1 public Distance(int x0, int y0, int x1, int y1) {<br />2    point0 = new java.awt.Point(x0, y0);<br />3    point1 = new java.awt.Point(x1, y1);<br />4 }<br /><br /><br /><br /><br />The constructor above consists of five parts:<br /><br />The optional access modifier(s).<br />In this case, the constructor is declared public<br />The constructor name, which must match the class name exactly: Distance in this case.<br />The constructor parameters.<br />The parameter list is required. Even if a constructor does not have any parameters, you must specify the empty list (). The parameter list declares the type and name of each of the method's parameters.<br />An optional throws clause which declares the exceptions that the constructor may throw. This constructor does not declare any exceptions.<br />The constructor body, which is a Java block (enclosed in {}). This constructor's body contains two statements.<br /><br />This constructor accepts four parameters, named x0, y0, x1 and y1. Each parameter requires a parameter type declaration, which in this example is int for all four parameters. The parameters in the parameter list are separated by commas.<br />The two assignments in this constructor use Java's new operator to allocate two java.awt.Point objects. The first allocates an object representing the first point, (x0, y0), and assigns it to the point0 instance variable (replacing the null value that the instance variable was initialized to). The second statement allocates a second java.awt.Point instance with (x1, y1) and assigns it to the point1 instance variable.<br />This is the constructor for the Distance class. Distance implicitly extends from java.lang.Object. Java inserts a call to the super constructor as the first executable statement of the constructor if there is not one explicitly coded. The above constructor body is equivalent to the following body with the explicit super constructor call:<br /><br /><br /><br />Code section 2.5: Super constructor.<br /><br /><br />1 {<br />2    super();<br />3    point0 = new java.awt.Point(x0, y0);<br />4    point1 = new java.awt.Point(x1, y1);<br />5 }<br /><br /><br /><br /><br />While it is true that this class could be implemented in other ways, such as simply storing the coordinates of the two points and computing the distance as , this class instead uses the existing java.awt.Point class. This choice matches the abstract definition of this class: to print the distance between two points on the plane. We take advantage of existing behavior already implemented in the Java platform rather than implementing it again. We will see later how to make the program more flexible without adding much complexity, because we choose to use object abstractions here. However, the key point is that this class uses information hiding. That is, how the class stores its state or how it computes the distance is hidden. We can change this implementation without altering how clients use and invoke the class.<br />"",""Reflection is the mechanism by which Java exposes the features of a class during runtime, allowing Java programs to enumerate and access a class' methods, fields, and constructors as objects. In other words, there are object-based mirrors that reflect the Java object model, and you can use these objects to access an object's features using runtime API constructs instead of compile-time language constructs. Each object instance has a getClass() method, inherited from java.lang.Object, which returns an object with the runtime representation of that object's class; this object is an instance of the java.lang.Class, which in turn has methods that return the fields, methods, constructors, superclass, and other properties of that class. You can use these reflection objects to access fields, invoke methods, or instantiate instances, all without having compile-time dependencies on those features. The Java runtime provides the corresponding classes for reflection. Most of the Java classes that support reflection are in the java.lang.reflect package. Reflection is most useful for performing dynamic operations with Java — operations that are not hard-coded into a source program, but that are determined at run time. One of the most important aspects of reflection is dynamic class loading.<br />"",""One way to understand how reflection works is to use reflection to model how the Java Runtime Environment (JRE) loads and executes a class. When you invoke a Java program<br /><br /><br /><br />Console<br /><br />java fully-qualified-class-name arg0 ... argn<br /><br /><br /><br /><br />and pass it command line arguments, the JRE must<br /><br />put the command line arguments arg0 ... argn into a String[] array<br />dynamically load the target class named by fully-qualified-class-name<br />access the public static void main(String[]) method<br />invoke the main method, passing the string array main String[].<br /><br />Steps 2, 3, and 4 can be accomplished with Java reflection. Below is an example of loading the Distance class, locating the main method, (see Understanding a Java Program) and invoking it via reflection.<br /><br /><br /><br />Code section 10.1: main() method invocation.<br /><br /><br /> 1 public static void invokeMain()<br /> 2    throws ClassNotFoundException,<br /> 3    \tExceptionInInitializerError,<br /> 4    \tIllegalAccessException,<br /> 5    \tIllegalArgumentException,<br /> 6    \tInvocationTargetException,<br /> 7    \tNoSuchMethodException,<br /> 8    \tSecurityException {<br /> 9    Class<?> distanceClass = Class.forName(\""Distance\"");<br />10    String[] points = {\""0\"", \""0\"", \""3\"", \""4\""};<br />11    Method mainMethod = distanceClass.getMethod(\""main\"", String[].class);<br />12    Object result = mainMethod.invoke(null, (Object) points);<br />13 }<br /><br /><br /><br /><br />This code is obviously more complicated than simply calling<br /><br /><br /><br />Code section 10.2: main() method calling.<br /><br /><br />1 Distance.main(new String[]{\""0\"", \""0\"", \""3\"", \""4\""});<br /><br /><br /><br /><br />However, the main Java runtime does not know about the Distance class. The name of the class to execute is a runtime value. Reflection allows a Java program to work with classes even though the classes are not known when the program was written. Let's explore what the invokeMain method is doing. The first statement at line 9 is an example of dynamic class loading. The forName() method will load a Java class and return an instance of java.lang.Class that results from loading the class. In this case, we are loading the class \""Distance\"" from the default package. We store the class object in the local variable distanceClass; its type is Class<?>. The second statement at line 10 simply creates a String array with the four command line arguments we wish to pass to the main method of the Distance class. The third statement at line 11 performs a reflection operation on the Distance class. The getMethod() method is defined for the Class class. It takes a variable number of parameters: the method name is the first parameter and the remaining parameters are the types of each of main's parameters. The method name is trivial: we want to invoke the main method, so we pass in the name \""main\"". We then add a Class variable for each of the method parameters. main accepts one parameter (String[] args) so we add a single Class element representing the String[]. The getMethod method has a return type of java.lang.reflect.Method; we store the result in a local variable named mainMethod. Finally, we invoke the method by calling the invoke() method of the Method instance. This method's first parameter is the instance to invoke on, and the remaining parameters are for the invokee's parameters. Since we are invoking a static method and not an instance method, we pass null as the instance argument. Since we only have a single parameter we pass it as the second argument. However, we must cast the parameter to Object to indicate that the array is the parameter, and not that the parameters are in the array. See varargs for more details on this.<br /><br /><br /><br />Code section 10.3: invoke() call.<br /><br /><br />1 Object result = mainMethod.invoke(null, arguments);<br /><br /><br /><br /><br />The invoke() method returns an Object that will contain the result that the reflected method returns. In this case, our main method is a void method, so we ignore the return type. Most of the methods in this short invokeMain method may throw various exceptions. The method declares all of them in its signatures. Here is a brief rundown of what might throw an exception:<br /><br />Class.forName(String) will throw ClassNotFoundException, if the named class cannot be located.<br />Class.forName(String) will throw ExceptionInInitializerError, if the class could not be loaded due the static initializer throwing an exception or a static field's initialization throwing an exception.<br />Class.getMethod(String name, Class parameterTypes[]) will throw<br /><br />NoSuchMethodException, if a matching method is not found, or is not public (use getDeclaredMethod to get a non-public method).<br />SecurityException, if a security manager is installed and calling the method would result in an access violation (for example, the method is in the sun.* package designed for internal use only).<br /><br /><br />Method.invoke(Object instance, Object... arguments) may throw:<br /><br />IllegalAccessException, if this method is invoked in a manner that violates its access modifiers.<br />IllegalArgumentException for various reasons, including<br /><br />passing an instance that does not implement this method.<br />the actual arguments do not match the method's arguments<br /><br /><br />InvocationTargetException, if the underlying method (main in this case) throws an exception.<br /><br /><br /><br />In addition to these exceptions, there are also errors and runtime exceptions that these methods may throw.<br /><br /><br /><br /><br /><br /><br /><br />To do:<br />Add some exercises like the ones in Variables<br /><br /><br /><br /><br /><br /><br /> Graphics and Media<br />Java Programming/Reflection<br />Overview<br />Dynamic Class Loading<br />"",""Next, let's take a look at applying an adaptor to our design. Adaptors are used to add functionality to the event handling process that:<br /><br />is general to the process and not specific to any one listener; or<br />is not supposed to affect the implementation of specific listeners.<br /><br />According to the Event Model specification a typical use case for an adaptor is to add routing logic for events. But you can also add filtering or logging. In our case, let's do that: add logging of the numbers as \""proof\"" for the calculations done in the listeners.<br />An adaptor, as explained earlier, is a class that sits between the event source and the listeners. From the point of view of the event source, it masquerades as a listener (so it must implement the listener interface). From the point of view of the listeners it pretends to be the event source (so it should have add and remove methods). In other words, to write an adaptor you have to repeat some code from the event source (to manage listeners) and you have to re-implement the event notification methods to do some extra stuff and then pass the event on to the actual listeners.<br />In our case we need an adaptor that writes the numbers to a log file. Keeping it simple once again, let's settle for an adaptor that:<br /><br />Uses a fixed log file name and overwrites that log file with every program run.<br />Opens a FileWriter in the constructor and just keeps it open.<br />Implements the numberRead method by writing the number to the FileWriter.<br />Implements the numberStreamTerminated method by closing the FileWriter.<br /><br />Also, we can make life easy on ourselves by just copying all the code we need to manage listeners over from the NumberReader class. Again, in a real program you'd want to do this differently. Note that each notification method implementation also passes the event on to all the real listeners:<br /><br /><br /><br />Code listing 1.6: NumberReaderLoggingAdaptor.<br /><br /><br />package org.wikibooks.en.javaprogramming.example;<br /><br />import java.io.BufferedWriter;<br />import java.io.FileWriter;<br />import java.io.IOException;<br />import java.util.HashSet;<br />import java.util.Set;<br /><br />public class NumberReaderLoggingAdaptor implements NumberReadListener {<br />    private Set<NumberReadListener> listeners;<br />    private BufferedWriter output;<br />   <br />    public NumberReaderLoggingAdaptor() {<br />        listeners = new HashSet<NumberReadListener>();<br />        try {<br />            output = new BufferedWriter(new FileWriter(\""numberLog.log\""));<br />        } catch (IOException e) {<br />            // TODO Auto-generated catch block<br />            e.printStackTrace();<br />        }<br />    }<br />   <br />    public void addNumberReadListener(NumberReadListener listener) {<br />        this.listeners.add(listener);<br />    }<br />   <br />    public void removeNumberReadListener(NumberReadListener listener) {<br />        this.listeners.remove(listener);<br />    }<br />   <br />   <br />    @Override<br />    public void numberRead(NumberReadEvent numberReadEvent) {<br />        try {<br />            output.write(numberReadEvent.getNumber() + \""\\n\"");<br />        } catch (Exception e) {<br />           <br />        }<br />        for (NumberReadListener numberReadListener: listeners) {<br />            numberReadListener.numberRead(numberReadEvent);<br />        }<br />    }<br /><br />    @Override<br />    public void numberStreamTerminated(NumberReadEvent numberReadEvent) {<br />        try {<br />            output.flush();<br />            output.close();<br />        } catch (Exception e) {<br />           <br />        }<br />        for (NumberReadListener numberReadListener: listeners) {<br />            numberReadListener.numberStreamTerminated(numberReadEvent);<br />        }<br />    }<br /><br />}<br /><br /><br /><br /><br />Of course, to make the adaptor work we have to make some changes to the bootstrap code:<br /><br /><br /><br />Code listing 1.7: Main.<br /><br /><br />package org.wikibooks.en.javaprogramming.example;<br /><br />public class Main {<br /><br />    public static void main(String[] args) {<br />        NumberReader reader = new NumberReader();<br />        NumberReadListener listener = new NumberReadListenerImpl();<br />        NumberReaderLoggingAdaptor adaptor = new NumberReaderLoggingAdaptor();<br />        adaptor.addNumberReadListener(listener);<br />        reader.addNumberReadListener(adaptor);<br />        reader.start();<br />    }<br />}<br /><br /><br /><br /><br />But note how nicely and easily we can re-link the objects in our system. The fact that adaptors and listeners both implement the listener interface and the adaptor and event source both look like event sources means that we can hook the adaptor into the system without having to change a single statement in the classes that we developed earlier.<br />And of course, if we run the same example as given above, the numbers are now recorded in a log file.<br />"",""We start with basic transfer object:<br /><br /><br /><br />Code listing 10.1: DummyTo.java<br /><br /><br /> 1 package com.test;<br /> 2  <br /> 3 public class DummyTo {<br /> 4     private String name;<br /> 5     private String address;<br /> 6  <br /> 7     public String getName() {<br /> 8         return name;<br /> 9     }<br />10  <br />11     public void setName(String name) {<br />12         this.name = name;<br />13     }<br />14  <br />15     public String getAddress() {<br />16         return address;<br />17     }<br />18  <br />19     public void setAddress(String address) {<br />20         this.address = address;<br />21     }<br />22  <br />23     public DummyTo(String name, String address) {<br />24         this.name = name;<br />25         this.address = address;<br />26     }<br />27  <br />28     public DummyTo() {<br />29         this.name = new String();<br />30         this.address = new String();<br />31     }<br />32  <br />33     public String toString(String appendBefore) {<br />34         return appendBefore + \"" \"" + name + \"", \"" + address;<br />35     }<br />36 }<br /><br /><br /><br /><br />Following is the example for invoking method from the above mentioned to dynamically. Code is self explanatory.<br /><br /><br /><br /><br /><br /><br />Code listing 10.2: ReflectTest.java<br /><br /><br /> 1 package com.test;<br /> 2  <br /> 3 import java.lang.reflect.Constructor;<br /> 4 import java.lang.reflect.InvocationTargetException;<br /> 5 import java.lang.reflect.Method;<br /> 6  <br /> 7 public class ReflectTest {<br /> 8     public static void main(String[] args) {<br /> 9         try {<br />10             Class<?> dummyClass = Class.forName(\""com.test.DummyTo\"");<br />11  <br />12             // parameter types for methods<br />13             Class<?>[] partypes = new Class[]{String.class};<br />14  <br />15             // Create method object. methodname and parameter types<br />16             Method meth = dummyClass.getMethod(\""toString\"", partypes);<br />17  <br />18             // parameter types for constructor<br />19             Class<?>[] constrpartypes = new Class[]{String.class, String.class};<br />20  <br />21             //Create constructor object. parameter types<br />22             Constructor<?> constr = dummyClass.getConstructor(constrpartypes);<br />23  <br />24             // create instance<br />25             Object dummyto = constr.newInstance(new Object[]{\""Java Programmer\"", \""India\""});<br />26  <br />27             // Arguments to be passed into method<br />28             Object[] arglist = new Object[]{\""I am\""};<br />29  <br />30             // invoke method!!<br />31             String output = (String) meth.invoke(dummyto, arglist);<br />32             System.out.println(output);<br />33  <br />34         } catch (ClassNotFoundException e) {<br />35             e.printStackTrace();<br />36         } catch (SecurityException e) {<br />37             e.printStackTrace();<br />38         } catch (NoSuchMethodException e) {<br />39             e.printStackTrace();<br />40         } catch (IllegalArgumentException e) {<br />41             e.printStackTrace();<br />42         } catch (IllegalAccessException e) {<br />43             e.printStackTrace();<br />44         } catch (InvocationTargetException e) {<br />45             e.printStackTrace();<br />46         } catch (InstantiationException e) {<br />47             e.printStackTrace();<br />48         }<br />49     }<br />50 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Console for Code listing 10.2<br /><br />I am Java Programmer, India<br /><br /><br /><br /><br /><br /><br />Conclusion: Above examples demonstrate the invocation of method dynamically using reflection.<br /><br /><br /><br /><br /><br /><br /><br />To do:<br />Add some exercises like the ones in Variables<br /><br /><br /><br /><br /><br /><br /> Dynamic Class Loading<br />Java Programming/Reflection<br />Dynamic Invocation<br />Accessing Private Features with Reflection<br />"",""To execute your first Java program, follow the instructions below:<br /><br /><br /><br /><br /><br />1.<br />Proceed only if you have successfully installed and configured your system for Java as discussed here.<br /><br /><br />2.<br />Open your preferred text editor — this is the editor you set while installing the Java platform.<br /><br /><br /><br />For example, Notepad or Notepad++ on Windows; Gedit, Kate or SciTE on Linux; or, XCode on Mac OS, etc.<br /><br /><br />3.<br />Write the following lines of code in a new text document:<br /><br /><br /><br />Code listing 2.5: HelloWorld.java<br /><br /><br />public class HelloWorld {<br />  public static void main(String[] args) {<br />    System.out.println(\""Hello World!\"");<br />  }<br />}<br /><br /><br /><br /><br /><br /><br /><br />4.<br />Save the file as HelloWorld.java — the name of your file should be the same as the name of your class definition and followed by the .java extension. This name is case-sensitive, which means you need to capitalize the precise letters that were capitalized in the name for the class definition.<br /><br /><br />5.<br />Next, open your preferred command-line application.<br /><br /><br /><br />For example, Command Prompt on Windows; and, Terminal on Linux and Mac OS.<br /><br /><br />6.<br />In your command-line application, navigate to the directory where you just created your file. If you do not know how to do this, consider reading through our crash courses for command-line applications for Windows or Linux.<br /><br /><br />7.<br />Compile the Java source file using the following command which you can copy and paste in if you want:<br /><br /><br /><br />Compilation<br /><br />javac HelloWorld.java<br /><br /><br /><br /><br /><br /><br />If you obtain an error message like error: cannot read: HelloWorld.java 1 error, your file is not in the current folder or it is badly spelled. Did you navigate to the program's location in the command prompt using the cd (change directory) command?<br />If you obtain another message ending by 1 error or ... errors, there may be a mistake in your code. Are you sure all words are spelled correctly and with the exact case as shown? Are there semicolons and brackets in the appropriate spot? Are you missing a quote? Usually, modern IDEs would try coloring the entire source as a quote in this case.<br />If your computer emits beeps, then you may have illegal characters in your HelloWorld.java.<br />If no HelloWorld.class file has been created in the same folder, then you've got an error. Are you launching the javac program correctly?<br /><br /><br /><br /><br /><br /><br />8.<br />Once the compiler returns to the prompt, run the application using the following command:<br /><br /><br /><br />Execution<br /><br />java HelloWorld<br /><br /><br /><br /><br /><br /><br />If you obtain an error message like Exception in thread \""main\"" java.lang.NoClassDefFoundError: HelloWorld, the HelloWorld.class file is not in the current folder or it is badly spelled.<br />If you obtain an error message like Exception in thread \""main\"" java.lang.NoSuchMethodError: main, your source file may have been badly written.<br /><br /><br /><br /><br /><br /><br />9.<br />The above command should result in your command-line application displaying the following result:<br /><br /><br /><br />Output<br /><br />Hello World!<br /><br /><br /><br /><br /><br /><br /><br />Ask for help if the program did not execute properly in the Discussion page for this chapter.<br />"",""When an exception is caught, the exception contains the stack-trace, which describes the error and shows where the exception happened, where the problem is, where the application programmer should look to fix the problem. Sometime it is desirable to catch an exception and throw another new exception. If the new exception keep a reference to the first exception, the first exception is called a nesting exception.<br /><br /><br /><br /><br /><br /><br />Code listing 6.4: NestingExceptionExample.java<br /><br /><br /> 1 public class NestingExceptionExample {<br /> 2  <br /> 3   public static void main(String[] args) throws Exception {<br /> 4     Object[] localArgs = (Object[]) args;<br /> 5    <br /> 6     try {<br /> 7       Integer[] numbers = (Integer[]) localArgs;<br /> 8     } catch (ClassCastException originalException) {<br /> 9       Exception generalException = new Exception(<br />10         \""Horrible exception!\"",<br />11         originalException);<br />12       throw generalException;<br />13     }<br />14   }<br />15 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Output for Code listing 6.4<br /><br />Exception in thread \""main\"" java.lang.Exception: Horrible exception!<br />at NestingExceptionExample.main(NestingExceptionExample.java:9)<br />Caused by: java.lang.ClassCastException: [Ljava.lang.String; incompatible with [Ljava.lang.Integer;<br />at NestingExceptionExample.main(NestingExceptionExample.java:7)<br /><br /><br /><br /><br /><br /><br />The above code is an example of a nesting exception. When the Exception is thrown, by passing in the ClassCastException object reference as a parameter, the ClassCastException is nested in the newly created Exception, its stack-trace is appended together. When the Exception is caught, its stack-trace contains the original ClassCastException's stack-trace.<br />This is a kind of exception conversion, from one exception to another. For example, calling a remote object using RMI, the calling method has to deal with RemoteException which is thrown if something is wrong during the communication. For the application point of view, RemoteException has no meaning, it should be transparent to the application that a remote object was used or not. So the RemoteException should be converted to an application exception.<br />This conversion can also hide where the error is originated. The stack-trace starts when the exception is thrown. So when we catch and throw a new exception, the stack-trace starts at when the new exception was thrown, losing the original stack-trace. This was true with the earlier version of Java (before 1.4). Since then, a so called cause facility capabilities were built in the Throwable class.<br />A throwable contains a snapshot of the execution stack of its thread at the time it was created. It can also contain a message string that gives more information about the error. Finally, it can contain a cause: another throwable that caused this throwable to get thrown. The cause facility is also known as the chained exception facility, as the cause can, itself, have a cause, and so on, leading to a \""chain\"" of exceptions, each caused by another.<br />A cause can be associated with a throwable in two ways: via a constructor that takes the cause as an argument, or via the initCause(Throwable) method. New throwable classes that wish to allow causes to be associated with them should provide constructors that take a cause and delegate (perhaps indirectly) to one of the Throwable constructors that takes a cause. For example:<br /><br /><br /><br />Code section 6.26: Chaining-aware constructor.<br /><br /><br />1 try {<br />2     lowLevelOp();<br />3 } catch (LowLevelException le) {<br />4     throw new HighLevelException(le);<br />5 }<br /><br /><br /><br /><br />Because the initCause method is public, it allows a cause to be associated with any throwable, even a \""legacy throwable\"" whose implementation predates the addition of the exception chaining mechanism to Throwable. For example:<br /><br /><br /><br />Code section 6.27: Legacy constructor.<br /><br /><br />1 try {<br />2     lowLevelOp();<br />3 } catch (LowLevelException le) {<br />4     throw (HighLevelException) new HighLevelException().initCause(le);<br />5 }<br /><br /><br /><br /><br />Further, as of release 1.4, many general purpose Throwable classes (for example Exception, RuntimeException, Error) have been retrofitted with constructors that take a cause. This was not strictly necessary, due to the existence of the initCause method, but it is more convenient and expressive to delegate to a constructor that takes a cause.<br />By convention, class Throwable and its subclasses have two constructors, one that takes no arguments and one that takes a String argument that can be used to produce a detail message. Further, those subclasses that might likely have a cause associated with them should have two more constructors, one that takes a Throwable (the cause), and one that takes a String (the detail message) and a Throwable (the cause).<br /><br /><br /><br /><br /><br /><br /><br /><br />To do:<br />Add some exercises like the ones in Variables<br /><br /><br /><br /><br /><br /><br /> Stack trace<br />Java Programming<br />Nesting Exceptions<br />Concurrent Programming<br />"",""The constructor can be overloaded. You can define more than one constructor with different parameters. For example:<br /><br /><br /><br />Code listing 4.12: Constructors.<br /><br /><br /> 1 public class MyClass {<br /> 2 <br /> 3   private String memberField;<br /> 4  <br /> 5   /**<br /> 6    * MyClass Constructor, there is no input parameter<br /> 7    */<br /> 8   public MyClass() {<br /> 9      ...<br />10   }<br />11  <br />12   /**<br />13    * MyClass Constructor, there is one input parameter<br />14    */<br />15    public MyClass(String param1) {<br />16      memberField = param1;<br />17      ...<br />18   }<br />19 }<br /><br /><br /><br /><br />In the code listing 4.12, we defined two constructors, one with no input parameter, and one with one input parameter. You may ask which constructor will be called. Its depends how the object is created with the new keyword. See below:<br /><br /><br /><br />Code section 4.29: Constructor calls.<br /><br /><br />1 // The constructor with no input parameter will be called<br />2 MyClass obj1 = new MyClass();<br />3 <br />4 // The constructor with one input param. will be called<br />5 MyClass obj2 = new MyClass(\""Init Value\"");<br /><br /><br /><br /><br />In the code section 4.29, we created two objects from the same class, or we can also say that obj1 and obj2 both have the same type. The difference between the two is that in the first one the memberField field is not initialized, in the second one that is initialized to \""Init Value\"". A constructor may also be called from another constructor, see below:<br /><br /><br /><br />Code listing 4.13: Constructor pooling.<br /><br /><br /> 1 public class MyClass {<br /> 2 <br /> 3   private String memberField;<br /> 4  <br /> 5   /**<br /> 6    * MyClass Constructor, there is no input parameter<br /> 7    */<br /> 8   public MyClass() {<br /> 9     MyClass(\""Default Value\"");<br />10   }<br />11  <br />12   /**<br />13    * MyClass Constructor, there is one input parameter<br />14    */<br />15   public MyClass(String param1) {<br />16     memberField = param1;<br />17     ...<br />18   }<br />19 }<br /><br /><br /><br /><br />In the code listing 4.13, the constructor with no input parameter calls the other constructor with the default initial value. This call must be the first instruction of a constructor or else a compiler error will occur. The code gives an option to the user, to create the object with the default value or create the object with a specified value. The first constructor could have been written using the this keyword as well:<br /><br /><br /><br />Code section 4.30: Another constructor pooling.<br /><br /><br />1   public MyClass() {<br />2     this(\""Default Value\"");<br />3   }<br /><br /><br /><br /><br />Such a call reduces the code repetition.<br />""]}"
"{""result"":[""The break keyword exits a flow control loop, such as a for loop. It basically breaks the loop.<br />In the code section 3.34, the loop would print out all the numbers from 1 to 10, but we have a check for when i equals 5. When the loop reaches its fifth iteration, it will be cut short by the break statement, at which point it will exit the loop.<br /><br /><br /><br /><br /><br /><br />Code section 3.34: An interrupted for loop.<br /><br /><br />1 for (int i = 1; i <= 10; i++) {<br />2     System.out.println(i);<br />3     if (i == 5) {<br />4        System.out.println(\""STOP!\"");<br />5        break;<br />6     }<br />7 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Output for code section 3.34<br /><br />1<br />2<br />3<br />4<br />5<br />STOP!<br /><br /><br /><br /><br /><br /><br />The continue keyword jumps straight to the next iteration of a loop and evaluates the boolean expression controlling the loop. The code section 3.35 is an example of the continue statement in action:<br /><br /><br /><br /><br /><br /><br />Code section 3.35: A for loop with a skipped iteration.<br /><br /><br />1 for (int i = 1; i <= 10; i++) {<br />2     if (i == 5) {<br />3         System.out.println(\""Caught i == 5\"");<br />4         continue;<br />5     }<br />6     System.out.println(i);<br />7 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Output for code section 3.35<br /><br />1<br />2<br />3<br />4<br />Caught i == 5<br />6<br />7<br />8<br />9<br />10<br /><br /><br /><br /><br /><br /><br />As the break and continue statements reduce the readability of the code, it is recommended to reduce their use or replace them with the use of if and while blocks. Some IDE refactoring operations will fail because of such statements.<br /><br />Test your knowledge<br /><br />Question 3.2: Consider the following code:<br /><br /><br /><br />Question 3.2: Loops and conditions.<br /><br /><br /> 1 int numberOfItems = 5;<br /> 2 int currentItems = 0;<br /> 3 int currentCandidate = 1;<br /> 4 <br /> 5 while (currentItems < numberOfItems) {<br /> 6   currentCandidate = currentCandidate + 1;<br /> 7   System.out.println(\""Test with integer: \"" + currentCandidate);<br /> 8  <br /> 9   boolean found = true;<br />10   for (int i = currentCandidate - 1; i > 1; i--) {<br />11    <br />12     // Test if i is a divisor of currentCandidate<br />13     if ((currentCandidate % i) == 0) {<br />14       System.out.println(\""Not matching...\"");<br />15       found = false;<br />16       break;<br />17     }<br />18    <br />19   }<br />20  <br />21   if (found) {<br />22     System.out.println(\""Matching!\"");<br />23     currentItems = currentItems + 1;<br />24   }<br />25 }<br />26 <br />27 System.out.println(\""Find the value: \"" + currentCandidate);<br /><br /><br /><br /><br />What will be printed in the standard output?<br /><br />Answer<br /><br /><br /><br /><br />Output for Question 3.2<br /><br />Test with integer: 2<br />Matching!<br />Test with integer: 3<br />Matching!<br />Test with integer: 4<br />Not matching...<br />Test with integer: 5<br />Matching!<br />Test with integer: 6<br />Not matching...<br />Test with integer: 7<br />Matching!<br />Test with integer: 8<br />Not matching...<br />Test with integer: 9<br />Not matching...<br />Test with integer: 10<br />Not matching...<br />Test with integer: 11<br />Matching!<br />Find the value: 11<br /><br /><br /><br />The snippet is searching the 5th prime number, that is to say: 11. It iterates on each positive integer from 2 (2, 3, 4, 5, 6, 7, 8, 9, 10, 11...), among them, it counts the prime numbers (2, 3, 5, 7, 11) and it stops at the 5th one.<br />So the snippet first iterates on each positive integer from 2 using the while loop:<br /><br /><br /><br />Answer 3.2.1: while loop.<br /><br /><br /> 1 int numberOfItems = 5;<br /> 2 int currentItems = 0;<br /> 3 int currentCandidate = 1;<br /> 4 <br /> 5 while (currentItems < numberOfItems) {<br /> 6   currentCandidate = currentCandidate + 1;<br /> 7   System.out.println(\""Test with integer: \"" + currentCandidate);<br /> 8  <br /> 9   boolean found = true;<br />10   for (int i = currentCandidate - 1; i > 1; i--) {<br />11    <br />12     // Test if i is a divisor of currentCandidate<br />13     if ((currentCandidate % i) == 0) {<br />14       System.out.println(\""Not matching...\"");<br />15       found = false;<br />16       break;<br />17     }<br />18    <br />19   }<br />20  <br />21   if (found) {<br />22     System.out.println(\""Matching!\"");<br />23     currentItems = currentItems + 1;<br />24   }<br />25 }<br />26 <br />27 System.out.println(\""Find the value: \"" + currentCandidate);<br /><br /><br /><br /><br />For each iteration, the current number is either a prime number or not. If it is a prime number, the code at the left will be executed. If it is not a prime number, the code at the right will be executed.<br /><br /><br /><br /><br /><br /><br />Answer 3.2.2: A prime number.<br /><br /><br /> 1 int numberOfItems = 5;<br /> 2 int currentItems = 0;<br /> 3 int currentCandidate = 1;<br /> 4 <br /> 5 while (currentItems < numberOfItems) {<br /> 6   currentCandidate = currentCandidate + 1;<br /> 7   System.out.println(\""Test with integer: \"" + currentCandidate);<br /> 8  <br /> 9   boolean found = true;<br />10   for (int i = currentCandidate - 1; i > 1; i--) {<br />11    <br />12     // Test if i is a divisor of currentCandidate<br />13     if ((currentCandidate % i) == 0) {<br />14       System.out.println(\""Not matching...\"");<br />15       found = false;<br />16       break;<br />17     }<br />18    <br />19   }<br />20  <br />21   if (found) {<br />22     System.out.println(\""Matching!\"");<br />23     currentItems = currentItems + 1;<br />24   }<br />25 }<br />26 <br />27 System.out.println(\""Find the value: \"" + currentCandidate);<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Answer 3.2.3: Not a prime number.<br /><br /><br /> 1 int numberOfItems = 5;<br /> 2 int currentItems = 0;<br /> 3 int currentCandidate = 1;<br /> 4 <br /> 5 while (currentItems < numberOfItems) {<br /> 6   currentCandidate = currentCandidate + 1;<br /> 7   System.out.println(\""Test with integer: \"" + currentCandidate);<br /> 8  <br /> 9   boolean found = true;<br />10   for (int i = currentCandidate - 1; i > 1; i--) {<br />11    <br />12     // Test if i is a divisor of currentCandidate<br />13     if ((currentCandidate % i) == 0) {<br />14       System.out.println(\""Not matching...\"");<br />15       found = false;<br />16       break;<br />17     }<br />18    <br />19   }<br />20  <br />21   if (found) {<br />22     System.out.println(\""Matching!\"");<br />23     currentItems = currentItems + 1;<br />24   }<br />25 }<br />26 <br />27 System.out.println(\""Find the value: \"" + currentCandidate);<br /><br /><br /><br /><br /><br /><br /><br />The prime numbers are counted using currentItems. When currentItems is equal to numberOfItems (5), the program go out of the while loop. currentCandidate contains the last number, that is to say the 5th prime number:<br /><br /><br /><br />Answer 3.2.4: End of the program.<br /><br /><br /> 1 int numberOfItems = 5;<br /> 2 int currentItems = 0;<br /> 3 int currentCandidate = 1;<br /> 4 <br /> 5 while (currentItems < numberOfItems) {<br /> 6   currentCandidate = currentCandidate + 1;<br /> 7   System.out.println(\""Test with integer: \"" + currentCandidate);<br /> 8  <br /> 9   boolean found = true;<br />10   for (int i = currentCandidate - 1; i > 1; i--) {<br />11    <br />12     // Test if i is a divisor of currentCandidate<br />13     if ((currentCandidate % i) == 0) {<br />14       System.out.println(\""Not matching...\"");<br />15       found = false;<br />16       break;<br />17     }<br />18    <br />19   }<br />20  <br />21   if (found) {<br />22     System.out.println(\""Matching!\"");<br />23     currentItems = currentItems + 1;<br />24   }<br />25 }<br />26 <br />27 System.out.println(\""Find the value: \"" + currentCandidate);<br />"",""Actually, there are no two-dimensional arrays in Java. However, an array can contain any class of object, including an array:<br /><br /><br /><br />Code section 3.56: Two-dimensional arrays.<br /><br /><br />1 String[][] twoDimArray = {{\""a\"", \""b\"", \""c\"", \""d\"", \""e\""},<br />2                           {\""f\"", \""g\"", \""h\"", \""i\"", \""j\""},<br />3                           {\""k\"", \""l\"", \""m\"", \""n\"", \""o\""}};<br />4 <br />5 int[][] twoDimIntArray = {{ 0,  1,  2,  3,  4},<br />6                           {10, 11, 12, 13, 14},<br />7                           {20, 21, 22, 23, 24}};<br /><br /><br /><br /><br />It's not exactly equivalent to two-dimensional arrays because the size of the sub-arrays may vary. The sub-array reference can even be null. Consider:<br /><br /><br /><br />Code section 3.57: Weird two-dimensional array.<br /><br /><br />1 String[][] weirdTwoDimArray = {{\""10\"", \""11\"", \""12\""},<br />2                                null,<br />3                                {\""20\"", \""21\"", \""22\"", \""23\"", \""24\""}};<br /><br /><br /><br /><br />Note that the length of a two-dimensional array is the number of one-dimensional arrays it contains. In the above example, weirdTwoDimArray.length is 3, whereas weirdTwoDimArray[2].length is 5.<br />In the code section 3.58, we defined an array that has three elements, each element contains an array having 5 elements. We could create the array having the 5 elements first and use that one in the initialize block.<br /><br /><br /><br />Code section 3.58: Included array.<br /><br /><br />1 String[] oneDimArray = {\""00\"", \""01\"", \""02\"", \""03\"", \""04\""};<br />2 String[][] twoDimArray = {oneDimArray,<br />3                           {\""10\"", \""11\"", \""12\"", \""13\"", \""14\""},<br />4                           {\""20\"", \""21\"", \""22\"", \""23\"", \""24\""}};<br /><br /><br /><br /><br /><br />Test your knowledge<br /><br />Question 3.21: Consider the following code:<br /><br /><br /><br />Question 3.21: The alphabet.<br /><br /><br />1 String[][] alphabet = {{\""a\"", \""b\"", \""c\"", \""d\"", \""e\""},<br />2                           {\""f\"", \""g\"", \""h\"", \""i\"", \""j\""},<br />3                           {\""k\"", \""l\"", \""m\"", \""n\"", \""o\""},<br />4                           {\""p\"", \""q\"", \""r\"", \""s\"", \""t\""},<br />5                           {\""u\"", \""v\"", \""w\"", \""x\"", \""y\""},<br />6                           {\""z\""}};<br /><br /><br /><br /><br />Print the whole alphabet in the standard output.<br /><br />Answer<br /><br /><br /><br /><br />Question 3.21: Answer21.java<br /><br /><br /> 1 public class Answer21 {<br /> 2   public static void main(String[] args) {<br /> 3     String[][] alphabet = {{\""a\"", \""b\"", \""c\"", \""d\"", \""e\""},<br /> 4                           {\""f\"", \""g\"", \""h\"", \""i\"", \""j\""},<br /> 5                           {\""k\"", \""l\"", \""m\"", \""n\"", \""o\""},<br /> 6                           {\""p\"", \""q\"", \""r\"", \""s\"", \""t\""},<br /> 7                           {\""u\"", \""v\"", \""w\"", \""x\"", \""y\""},<br /> 8                           {\""z\""}};<br /> 9 <br />10     for (int i = 0; i < alphabet.length; i++) {<br />11       for (int j = 0; j < alphabet[i].length; j++) {<br />12         System.out.println(alphabet[i][j]);<br />13       }<br />14     }<br />15   }<br />16 }<br /><br /><br /><br /><br />i will be the indexes of the main array and j will be the indexes of all the sub-arrays. We have to first iterate on the main array. We have to read the size of the array. Then we iterate on each sub-array. We have to read the size of each array as it may vary. Doing so, we iterate on all the sub-array items using the indexes. All the items will be read in the right order.<br />"",""Next, let's take a look at applying an adaptor to our design. Adaptors are used to add functionality to the event handling process that:<br /><br />is general to the process and not specific to any one listener; or<br />is not supposed to affect the implementation of specific listeners.<br /><br />According to the Event Model specification a typical use case for an adaptor is to add routing logic for events. But you can also add filtering or logging. In our case, let's do that: add logging of the numbers as \""proof\"" for the calculations done in the listeners.<br />An adaptor, as explained earlier, is a class that sits between the event source and the listeners. From the point of view of the event source, it masquerades as a listener (so it must implement the listener interface). From the point of view of the listeners it pretends to be the event source (so it should have add and remove methods). In other words, to write an adaptor you have to repeat some code from the event source (to manage listeners) and you have to re-implement the event notification methods to do some extra stuff and then pass the event on to the actual listeners.<br />In our case we need an adaptor that writes the numbers to a log file. Keeping it simple once again, let's settle for an adaptor that:<br /><br />Uses a fixed log file name and overwrites that log file with every program run.<br />Opens a FileWriter in the constructor and just keeps it open.<br />Implements the numberRead method by writing the number to the FileWriter.<br />Implements the numberStreamTerminated method by closing the FileWriter.<br /><br />Also, we can make life easy on ourselves by just copying all the code we need to manage listeners over from the NumberReader class. Again, in a real program you'd want to do this differently. Note that each notification method implementation also passes the event on to all the real listeners:<br /><br /><br /><br />Code listing 1.6: NumberReaderLoggingAdaptor.<br /><br /><br />package org.wikibooks.en.javaprogramming.example;<br /><br />import java.io.BufferedWriter;<br />import java.io.FileWriter;<br />import java.io.IOException;<br />import java.util.HashSet;<br />import java.util.Set;<br /><br />public class NumberReaderLoggingAdaptor implements NumberReadListener {<br />    private Set<NumberReadListener> listeners;<br />    private BufferedWriter output;<br />   <br />    public NumberReaderLoggingAdaptor() {<br />        listeners = new HashSet<NumberReadListener>();<br />        try {<br />            output = new BufferedWriter(new FileWriter(\""numberLog.log\""));<br />        } catch (IOException e) {<br />            // TODO Auto-generated catch block<br />            e.printStackTrace();<br />        }<br />    }<br />   <br />    public void addNumberReadListener(NumberReadListener listener) {<br />        this.listeners.add(listener);<br />    }<br />   <br />    public void removeNumberReadListener(NumberReadListener listener) {<br />        this.listeners.remove(listener);<br />    }<br />   <br />   <br />    @Override<br />    public void numberRead(NumberReadEvent numberReadEvent) {<br />        try {<br />            output.write(numberReadEvent.getNumber() + \""\\n\"");<br />        } catch (Exception e) {<br />           <br />        }<br />        for (NumberReadListener numberReadListener: listeners) {<br />            numberReadListener.numberRead(numberReadEvent);<br />        }<br />    }<br /><br />    @Override<br />    public void numberStreamTerminated(NumberReadEvent numberReadEvent) {<br />        try {<br />            output.flush();<br />            output.close();<br />        } catch (Exception e) {<br />           <br />        }<br />        for (NumberReadListener numberReadListener: listeners) {<br />            numberReadListener.numberStreamTerminated(numberReadEvent);<br />        }<br />    }<br /><br />}<br /><br /><br /><br /><br />Of course, to make the adaptor work we have to make some changes to the bootstrap code:<br /><br /><br /><br />Code listing 1.7: Main.<br /><br /><br />package org.wikibooks.en.javaprogramming.example;<br /><br />public class Main {<br /><br />    public static void main(String[] args) {<br />        NumberReader reader = new NumberReader();<br />        NumberReadListener listener = new NumberReadListenerImpl();<br />        NumberReaderLoggingAdaptor adaptor = new NumberReaderLoggingAdaptor();<br />        adaptor.addNumberReadListener(listener);<br />        reader.addNumberReadListener(adaptor);<br />        reader.start();<br />    }<br />}<br /><br /><br /><br /><br />But note how nicely and easily we can re-link the objects in our system. The fact that adaptors and listeners both implement the listener interface and the adaptor and event source both look like event sources means that we can hook the adaptor into the system without having to change a single statement in the classes that we developed earlier.<br />And of course, if we run the same example as given above, the numbers are now recorded in a log file.<br />"",""This is where things get interesting: the event source class. This is the interesting place because this is where we must put code to read the number stream, code to send events to all the listeners and code to manage listeners (add and remove them and keep track of them).<br />Let's start by thinking about keeping track of listeners. Normally this is a tricky business, since you have to take all sorts of multithreading concerns into account. But we're being simple in this example, so let's just stick with a simple java.util.Set of listeners. Which we can initialize in the constructor:<br /><br /><br /><br />Code section 1.1: The constructor<br /><br /><br />private Set<NumberReadListener> listeners;<br />   <br />public NumberReader() {<br />    listeners = new HashSet<NumberReadListener>();<br />}<br /><br /><br /><br /><br />That choice makes it really easy to implement adding and removing of listeners:<br /><br /><br /><br />Code section 1.2: The register/deregister<br /><br /><br />public void addNumberReadListener(NumberReadListener listener) {<br />    this.listeners.add(listener);<br />}<br /><br />public void removeNumberReadListener(NumberReadListener listener) {<br />    this.listeners.remove(listener);<br />}<br /><br /><br /><br /><br />We won't actually use the remove method in this example — but recall that the Model says it must be present.<br />Another advantage of this simple choice is that notification of all the listeners is easy as well. We can just assume any listeners will be in the set and iterate over them. And since the notification methods are synchronous (rule of the model) we can just call them directly:<br /><br /><br /><br />Code section 1.3: The notifiers<br /><br /><br />private void notifyListenersOfEndOfStream() {<br />    for (NumberReadListener numberReadListener : listeners) {<br />        numberReadListener.numberStreamTerminated(new NumberReadEvent(this, 0D));<br />    }<br />}<br /><br />private void notifyListeners(Double d) {<br />    for (NumberReadListener numberReadListener: listeners) {<br />        numberReadListener.numberRead(new NumberReadEvent(this, d));<br />    }<br />}<br /><br /><br /><br /><br />Note that we've made some assumptions here. For starters, we've assumed that we'll get the Double value d from somewhere. Also, we've assumed that no listener will ever care about the number value in the end-of-stream notification and have passed in the fixed value 0 for that event.<br />Finally we must deal with reading the number stream. We'll use the Console class for that and just keep on reading numbers until there are no more:<br /><br /><br /><br />Code section 1.4: The main method<br /><br /><br />public void start() {<br />    Console console = System.console();<br />    if (console != null) {<br />        Double d = null;<br />        do {<br />            String readLine = console.readLine(\""Enter a number: \"", (Object[])null);<br />            d = getDoubleValue(readLine);<br />            if (d != null) {<br />                notifyListeners(d);<br />            }<br />        } while (d != null);<br />        notifyListenersOfEndOfStream();<br />    }<br />}<br /><br /><br /><br /><br />Note how we've hooked the number-reading loop into the event handling mechanism by calling the notify methods? The entire class looks like this:<br /><br /><br /><br />Code listing 1.4: NumberReader.<br /><br /><br />package org.wikibooks.en.javaprogramming.example;<br /><br />import java.io.Console;<br />import java.util.HashSet;<br />import java.util.Set;<br /><br />public class NumberReader {<br />    private Set<NumberReadListener> listeners;<br />   <br />    public NumberReader() {<br />        listeners = new HashSet<NumberReadListener>();<br />    }<br />   <br />    public void addNumberReadListener(NumberReadListener listener) {<br />        this.listeners.add(listener);<br />    }<br />   <br />    public void removeNumberReadListener(NumberReadListener listener) {<br />        this.listeners.remove(listener);<br />    }<br />   <br />    public void start() {<br />        Console console = System.console();<br />        if (console != null) {<br />            Double d = null;<br />            do {<br />                String readLine = console.readLine(\""Enter a number: \"", (Object[])null);<br />                d = getDoubleValue(readLine);<br />                if (d != null) {<br />                    notifyListeners(d);<br />                }<br />            } while (d != null);<br />            notifyListenersOfEndOfStream();<br />        }<br />    }<br /><br />    private void notifyListenersOfEndOfStream() {<br />        for (NumberReadListener numberReadListener: listeners) {<br />            numberReadListener.numberStreamTerminated(new NumberReadEvent(this, 0D));<br />        }<br />    }<br /><br />    private void notifyListeners(Double d) {<br />        for (NumberReadListener numberReadListener: listeners) {<br />            numberReadListener.numberRead(new NumberReadEvent(this, d));<br />        }<br />    }<br /><br />    private Double getDoubleValue(String readLine) {<br />        Double result;<br />        try {<br />            result = Double.valueOf(readLine);<br />        } catch (Exception e) {<br />            result = null;<br />        }<br />        return result;<br />    }<br />}<br />"",""In order to do arithmetic in Java, one must first declare at least one variable. Typically one declares a variable and assigns it a value before any arithmetic is done. Here's an example of declaring an integer variable:<br /><br /><br /><br />Code section 3.59: Variable assignation.<br /><br /><br />1 int x = 5;<br /><br /><br /><br /><br />After creating a variable, one can manipulate its value by using Java's operators: + (addition), - (subtraction), * (multiplication), / (integer division), % (modulo or remainder), ++ (pre- & postincrement by one), -- (pre- & postdecrement by one).<br /><br /><br /><br /><br /><br /><br />Code listing 3.10: Operators.java<br /><br /><br /> 1 public class Operators {<br /> 2   public static void main(String[] args) {<br /> 3     int x = 5;<br /> 4     System.out.println(\""x = \"" + x);<br /> 5     System.out.println();<br /> 6    <br /> 7     System.out.println(\""--- Addition             ---\"");<br /> 8     x = 5;<br /> 9     System.out.println(\""x + 2 = \"" + (x + 2));<br />10     System.out.println(\""x = \"" + x);<br />11     System.out.println();<br />12    <br />13     System.out.println(\""--- Subtraction          ---\"");<br />14     x = 5;<br />15     System.out.println(\""x - 4 = \"" + (x - 4));<br />16     System.out.println(\""x = \"" + x);<br />17     System.out.println();<br />18    <br />19     System.out.println(\""--- Multiplication       ---\"");<br />20     x = 5;<br />21     System.out.println(\""x * 3 = \"" + (x * 3));<br />22     System.out.println(\""x = \"" + x);<br />23     System.out.println();<br />24    <br />25     System.out.println(\""--- (Integer) Division   ---\"");<br />26     x = 5;<br />27     System.out.println(\""x / 2 = \"" + (x / 2));<br />28     System.out.println(\""x = \"" + x);<br />29     System.out.println();<br />30    <br />31     System.out.println(\""--- Modulo (Remainder)   ---\"");<br />32     x = 5;<br />33     System.out.println(\""x % 2 = \"" + (x % 2));<br />34     System.out.println(\""x = \"" + x);<br />35     System.out.println();<br />36    <br />37     System.out.println(\""--- Preincrement by one  ---\"");<br />38     x = 5;<br />39     System.out.println(\""++x   = \"" + (++x  ));<br />40     System.out.println(\""x = \"" + x);<br />41     System.out.println();<br />42    <br />43     System.out.println(\""--- Predecrement by one  ---\"");<br />44     x = 5;<br />45     System.out.println(\""--x   = \"" + (--x  ));<br />46     System.out.println(\""x = \"" + x);<br />47     System.out.println();<br />48    <br />49     System.out.println(\""--- Postincrement by one ---\"");<br />50     x = 5;<br />51     System.out.println(\""x++   = \"" + (x++  ));<br />52     System.out.println(\""x = \"" + x);<br />53     System.out.println();<br />54    <br />55     System.out.println(\""--- Postdecrement by one ---\"");<br />56     x = 5;<br />57     System.out.println(\""x--   = \"" + (x--  ));<br />58     System.out.println(\""x = \"" + x);<br />59     System.out.println();<br />60   }<br />61 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Console for Code listing 3.10<br /><br />x = 5<br /><br />--- Addition             ---<br />x + 2 = 7<br />x = 5<br /><br />--- Subtraction          ---<br />x - 4 = 1<br />x = 5<br /><br />--- Multiplication       ---<br />x * 3 = 15<br />x = 5<br /><br />--- (Integer) Division   ---<br />x / 2 = 2<br />x = 5<br /><br />--- Modulo (Remainder)   ---<br />x % 2 = 1<br />x = 5<br /><br />--- Preincrement by one  ---<br />++x   = 6<br />x = 6<br /><br />--- Predecrement by one  ---<br />--x   = 4<br />x = 4<br /><br />--- Postincrement by one ---<br />x++   = 5<br />x = 6<br /><br />--- Postdecrement by one ---<br />x--   = 5<br />x = 4<br /><br /><br /><br /><br /><br /><br />The division operator rounds towards zero: 5/2 is 2, and -5/2 is -2. The remainder operator has the same sign as the left operand; it is defined such that ((a/b)*b) + (a%b) is always equal to a. The preincrement, predecrement, postincrement, and postdecrement operators are special: they also change the value of the variable, by adding or subtracting one. The only difference is that preincrement/decrement returns the new value of the variable; postincrement returns the original value of the variable.<br /><br />Test your knowledge<br /><br />Question 3.8: Consider the following code:<br /><br /><br /><br />Question 3.8: Question8.java<br /><br /><br /> 1 public class Question8 {<br /> 2   public static void main(String[] args) {<br /> 3     int x = 10;<br /> 4     x = x + 10;<br /> 5     x = 2 * x;<br /> 6     x = x - 19;<br /> 7     x = x / 3;<br /> 8     System.out.println(x);<br /> 9   }<br />10 }<br /><br /><br /><br /><br />What will be printed in the standard output?<br /><br />Answer<br /><br /><br /><br /><br />Output for Question 3.8<br /><br />7<br /><br /><br /><br />int x = 10; => 10<br />x = x + 10; => 20<br />x = 2 * x; => 40<br />x = x - 19; => 21<br />x = x / 3; => 7<br /><br /><br /><br /><br />When using several operators in the same expression, one must consider Java's order of precedence. Java uses the standard PEMDAS (Parenthesis, Exponents, Multiplication and Division, Addition and Subtraction) order. When there are multiple instances of the same precedence, Java reads from left to right. Consider what the output of the following code would be:<br /><br /><br /><br /><br /><br /><br />Code section 3.60: Several operators.<br /><br /><br />1 System.out.println(10*5 + 100/10 - 5 + 7%2);<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Console for Code section 3.60<br /><br />56<br /><br /><br /><br /><br /><br /><br />The following chart shows how Java would compute this expression:<br /><br /><br /><br /><br />Figure 3.1: Computation of an arithmetic expression in the Java programming language<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Besides performing mathematical functions, there are also operators to assign numbers to variables (each example again uses the variable initialized as x = 5):<br /><br /><br /><br /><br /><br /><br />Code listing 3.11: Assignments.java<br /><br /><br /> 1 public class Assignments {<br /> 2   public static void main(String[] args) {<br /> 3     int x = 5;<br /> 4     x = 3;<br /> 5     System.out.println(\""Assignment                                       (x = 3) : \"" + x);<br /> 6 <br /> 7     x = 5;<br /> 8     x += 5;<br /> 9     System.out.println(\""Assign x plus another integer to itself          (x += 5): \"" + x);<br />10 <br />11     x = 5;<br />12     x -= 4;<br />13     System.out.println(\""Assign x minus another integer to itself         (x -= 4): \"" + x);<br />14 <br />15     x = 5;<br />16     x *= 6;<br />17     System.out.println(\""Assign x multiplied by another integer to itself (x *= 6): \"" + x);<br />18 <br />19     x = 5;<br />20     x /= 5;<br />21     System.out.println(\""Assign x divided by another integer to itself    (x /= 5): \"" + x);<br />22   }<br />23 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Console for Code listing 3.11<br /><br />Assignment                                       (x = 3) : 3<br />Assign x plus another integer to itself          (x += 5): 10<br />Assign x minus another integer to itself         (x -= 4): 1<br />Assign x multiplied by another integer to itself (x *= 6): 30<br />Assign x divided by another integer to itself    (x /= 5): 1<br />"",""A generic type can be defined for just a method:<br /><br /><br /><br />Code section 4.37: Generic method.<br /><br /><br />1 public <D> D assign(Collection<D> generic, D obj) {<br />2   generic.add(obj);<br />3   return obj;<br />4 }<br /><br /><br /><br /><br />Here a new identifier (D) has been chosen at the beginning of the method declaration. The type is specific to a method call and different types can be used for the same object instance:<br /><br /><br /><br />Code section 4.38: Generic method call.<br /><br /><br />1 Collection<Integer> numbers = new ArrayList<Integer>();<br />2 Integer number = assign(numbers, new Integer(1));<br />3 Collection<String> texts = new ArrayList<String>();<br />4 String text = assign(texts, \""Store it.\"");<br /><br /><br /><br /><br />The actual type will be defined by the type of the method parameter. Hence, the generic type can't be defined only for the return value as it wouldn't be resolved. See the Class<T> section for a solution.<br /><br />Test your knowledge<br /><br />Question 4.8: Consider the following class.<br /><br /><br /><br />Question 4.8: Question8.java<br /><br /><br /> 1 public class Question8<T> {<br /> 2   public T item;<br /> 3  <br /> 4   public T getItem() {<br /> 5     return item;<br /> 6   }<br /> 7  <br /> 8   public void setItem(T newItem) {<br /> 9     item = newItem;<br />10   }<br />11 <br />12   public static void main(String[] args) {<br />13     Question8<String> aQuestion = new Question8<String>();<br />14     aQuestion.setItem(\""Open your mind.\"");<br />15     aQuestion.display(aQuestion.getItem());<br />16   }<br />17 <br />18   public void display(String parameter) {<br />19     System.out.println(\""Here is the text: \"" + parameter);<br />20   }<br />21 <br />22   public void display(Integer parameter) {<br />23     System.out.println(\""Here is the number: \"" + parameter);<br />24   }<br />25 <br />26   public void display(Object parameter) {<br />27     System.out.println(\""Here is the object: \"" + parameter);<br />28   }<br />29 }<br /><br /><br /><br /><br />What will be displayed on the console?<br /><br />Answer<br /><br /><br /><br /><br />Console for Answer 4.8<br /><br />Here is the text: Open your mind.<br /><br /><br /><br />aQuestion.getItem() is typed as a string.<br />"",""The String class also allows for the modification of cases. The two methods that make this possible are toLowerCase() and toUpperCase().<br /><br /><br /><br /><br /><br /><br />Code section 3.96: Case modification.<br /><br /><br />1 String str = \""wIkIbOoKs\"";<br />2 System.out.println(str.toLowerCase());<br />3 System.out.println(str.toUpperCase());<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Output for Code section 3.96<br /><br />wikibooks<br />WIKIBOOKS<br /><br /><br /><br /><br /><br /><br />These methods are useful to do a search which is not case sensitive:<br /><br /><br /><br /><br /><br /><br />Code section 3.97: Text search.<br /><br /><br /> 1 String word = \""Integer\"";<br /> 2 String text = \""A number without a decimal part is an integer.\""<br /> 3   + \"" Integers are a list of digits.\"";<br /> 4 <br /> 5 ...<br /> 6 <br /> 7 // Remove the case<br /> 8 String lowerCaseWord = word.toLowerCase();<br /> 9 String lowerCaseText = text.toLowerCase();<br />10 <br />11 // Search<br />12 int index = lowerCaseText.indexOf(lowerCaseWord);<br />13 while (index != -1) {<br />14   System.out.println(word<br />15     + \"" appears at column \""<br />16     + (index + 1)<br />17     + \"".\"");<br />18   index = lowerCaseText.indexOf(lowerCaseWord, index + 1);<br />19 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Output for Code section 3.97<br /><br />Integer appears at column 38.<br />Integer appears at column 47.<br /><br /><br /><br /><br /><br /><br /><br />Test your knowledge<br /><br />Question 3.12: You have mail addresses in the following form: <firstName>.<lastName>@<companyName>.org<br />Write the String getDisplayName(String) method that receives the mail string as parameter and returns the readable person name like this: LASTNAME Firstname<br /><br />Answer<br /><br /><br /><br /><br />Answer 3.12: getDisplayName()<br /><br /><br /> 1 public static String getDisplayName(String mail) {<br /> 2   String displayName = null;<br /> 3  <br /> 4   if (mail != null) {<br /> 5     String[] mailParts = mail.split(\""@\"");<br /> 6     String namePart = mailParts[0];<br /> 7     String[] namesParts = namePart.split(\""\\\\.\"");<br /> 8    <br /> 9     // The last name<br />10     String lastName = namesParts[1];<br />11     lastName = lastName.toUpperCase();<br />12    <br />13     // The first name<br />14     String firstName = namesParts[0];<br />15    <br />16     String firstNameInitial = firstName.substring(0, 1);<br />17     firstNameInitial = firstNameInitial.toUpperCase();<br />18    <br />19     String firstNameEnd = firstName.substring(1);<br />20     firstNameEnd = firstNameEnd.toLowerCase();<br />21    <br />22     // Concatenation<br />23     StringBuilder displayNameBuilder = new StringBuilder(lastName).append(\"" \"").append(firstNameInitial).append(firstNameEnd);<br />24     displayName = displayNameBuilder.toString();<br />25   }<br />26  <br />27   return displayName;<br />28 }<br /><br /><br /><br /><br /><br />We only process non null strings,<br />We first split the mail into two parts to separate the personal information from the company information and we keep the name data,<br />Then we split the name information to separate the first name from the last name. As the split() method use regular expression and . is a wildcard character, we have to escape it (\\.). However, in a string, the \\ is also a special character, so we need to escape it too (\\\\.),<br />The last name is just capitalized,<br />As the case of all the first name characters will not be the same, we have to cut the first name. Only the first name initial will be capitalized,<br />Now we can concatenate all the fragments. We prefer to use a StringBuilder to do that.<br />"",""public class Distance {<br /><br />  private java.awt.Point point0, point1;<br /><br /><br /><br />  public Distance(int x0, int y0, int x1, int y1) {<br />    point0 = new java.awt.Point(x0, y0);<br />    point1 = new java.awt.Point(x1, y1);<br />  }<br /><br /><br /><br />  public void printDistance() {<br />    System.out.println(\""Distance between \"" + point0 + \"" and \"" + point1<br />      + \"" is \"" + point0.distance(point1));<br />  }<br /><br /><br /><br />  public static void main(String[] args) {<br />    Distance dist = new Distance(<br />      intValue(args[0]), intValue(args[1]),<br />      intValue(args[2]), intValue(args[3]));<br />    dist.printDistance();<br />  }<br /><br /><br /><br />  private static int intValue(String data) {<br />    return Integer.parseInt(data);<br />  }<br /><br /><br />}<br /><br /><br />Figure 2.2: Declarations and Definitions.<br /><br />Sequences of tokens are used to construct the next building blocks of Java classes as shown above: declarations and definitions. A class declaration provides the name and visibility of a class. In our example, public class Distance is the class declaration. It consists (in this case) of two keywords, public and class followed by the identifier Distance.<br />This means that we are defining a class named Distance. Other classes, or in our case, the command line, can refer to the class by this name. The public keyword is an access modifier which declares that this class and its members may be accessed from other classes. The class keyword, obviously, identifies this declaration as a class. Java also allows declarations of interfaces and annotations.<br />The class declaration is then followed by a block (surrounded by curly braces) which provides the class's definition (in blue in figure 2.2). The definition is the implementation of the class – the declaration and definitions of the class's members. This class contains exactly six members, which we will explain in turn.<br /><br />Two field declarations, named point0 and point1 (in green)<br />A constructor declaration (in orange)<br />Three method declarations (in red)<br />"",""Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null ? e==null : o.equals(e)).<br /><br /><br /><br />boolean contains(Object o)<br /><br />Different Method in ArrayList<br /><br /><br /> <br />public class ArrayListDemo {<br />\tpublic static void main(String[] args) {<br />\t\t// create an array list<br />\t\tArrayList al = new ArrayList();<br /><br />\t\t// add elements to the array list<br />\t\tal.add(\""A\"");<br />\t\tal.add(\""B\"");<br />\t\tal.add(\""C\"");<br />\t\tal.add(\""A\"");<br />\t\tal.add(\""D\"");<br />\t\tal.add(\""A\"");<br />\t\tal.add(\""E\"");<br />\t\tSystem.out.println(\""Contents of al : \"" + al);<br /><br />\t\t// find index of element in ArrayList<br />\t\tSystem.out.println(\""Index of D : \"" + al.indexOf(\""D\""));<br />\t\tSystem.out.println(\""Index of A : \"" + al.indexOf(\""A\""));<br /><br />\t\t// find index of element in ArrayList<br />\t\tSystem.out.println(\""Index of A : \"" + al.lastIndexOf(\""A\""));<br /><br />\t\t// get element at given Index<br />\t\tSystem.out.println(\""Element at Second Index : \"" + al.get(2));<br />\t\tSystem.out.println(\""Element at Sixth Index : \"" + al.get(6));<br />\t\t<br />\t\t//set element at given Index<br />\t\tal.set(3,\""B\""); // replacing third index element by \""B\""<br />\t\tSystem.out.println(\""Contents of al : \"" + al);<br />\t\t<br />\t\t//check ArrayList contains given element<br />\t\tSystem.out.println(\""ArrayList contain D : \""+al.contains(\""D\""));<br />\t\tSystem.out.println(\""ArrayList contain F : \""+al.contains(\""F\""));<br />\t}<br />}<br /><br />Output for Different Method in ArrayList<br /><br /><br /><br /><br /><br />Contents of al : [A, B, C, A, D, A, E]<br />Index of D : 4<br />Index of A : 0<br />Index of A : 5<br />Element at Second Index : C<br />Element at Sixth Index : E<br />Contents of al : [A, B, C, B, D, A, E]<br />ArrayList contain D : true<br />ArrayList contain F : false<br /><br /><br /><br /><br />Test your knowledge<br /><br />Question: Consider the following code:<br /><br /><br /><br /><br /><br /><br />public class ArrayListDemo {<br />\t\tpublic static void main(String[] args) {<br />\t<br />\t\tArrayList al = new ArrayList();<br /><br />\t\tal.add(\""A\"");<br />\t\tal.add(\""B\"");<br />\t\tal.add(\""C\"");<br />\t\tal.add(\""E\"");<br />\t\tal.add(\""F\"");<br />\t<br />\t\tal.remove(2);<br />\t\tal.remove(\""F\"");<br />\t\t<br />\t\tal.set(1, \""G\"");<br />\t\tal.add(\""H\"");<br />\t\tal.set(3, \""I\"");<br />\t\tSystem.out.println(\""Size of al : \"" + al.size());<br />\t\tSystem.out.println(\""Contents of al : \"" + al);<br /><br />\t}<br />  }<br /><br /><br /><br /><br /><br />In the example above, what is output?<br /><br />Answer<br /><br /><br /><br /><br /><br /><br />Size of al : 4<br />Contents of al : [A, G, E, I]<br /><br /><br /><br /><br /><br /><br /><br />Some more ArrayList methods:<br /><br /><br />Method<br />Description<br /><br /><br />Object clone()<br />Returns a shallow copy of this ArrayList.<br /><br /><br />Object[] toArray()<br />Returns an array containing all of the elements in this list in the correct order. Throws NullPointerException if the specified array is null.<br /><br /><br />void trimToSize()<br />Trims the capacity of this ArrayList instance to be the list's current size.<br /><br /><br />void ensureCapacity(int minCapacity)<br />Increases the capacity of this ArrayList instance, if necessary, to ensure that it can hold at least the number of elements specified by the minimum capacity argument.<br /><br /><br />protected void removeRange(int fromIndex, int toIndex)<br />Removes from this List all of the elements whose index is between fromIndex, inclusive and toIndex, exclusive.<br /><br /><br /><br /><br /> Collections<br />Java Programming<br />ArrayList<br />Map<br />"",""The most basic collection interface is called Collection. This interface gives the user a generic usage of a collection. All collections need to have the same basic operations. Those are:<br /><br />Adding element(s) to the collection<br />Removing element(s) from the collection<br />Obtaining the number of elements in the collection<br />Listing the contents of the collection, (Iterating through the collection)<br /><br /><br /><br /><br /><br /><br /><br />Code listing 5.1: CollectionProgram.java<br /><br /><br /> 1 import java.util.Collection;   // Interface<br /> 2 import java.util.ArrayList;    // Implementation<br /> 3 <br /> 4 public class CollectionProgram {<br /> 5 <br /> 6   public static void main(String[] args) {<br /> 7     Collection myCollection = new ArrayList();<br /> 8     myCollection.add(\""1\"");<br /> 9     myCollection.add(\""2\"");<br />10     myCollection.add(\""3\"");<br />11     System.out.println(\""The collection contains \"" + myCollection.size() + \"" item(s).\"");<br />12 <br />13     myCollection.clear();<br />14     if (myCollection.isEmpty()) {<br />15       System.out.println(\""The collection is empty.\"");<br />16     } else {<br />17       System.out.println(\""The collection is not empty.\"");<br />18     }<br />19   }<br />20 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Console for Code listing 5.1<br /><br />The collection contains 3 item(s).<br />The collection is empty.<br /><br /><br /><br /><br /><br /><br />When you put an object in a collection, this object is not actually in the collection. Only its object reference is added to the collection. This means that if an object is changed after it was put in an collection, the object in the collection also changes. The code listing 5.2 computes the seven next days from tomorrow and store each date in a list to read it after. See what happens:<br /><br /><br /><br /><br /><br /><br />Code listing 5.2: SevenNextDays.java<br /><br /><br /> 1 import java.util.ArrayList;<br /> 2 import java.util.Calendar;<br /> 3 import java.util.Collection;<br /> 4 import java.util.Date;<br /> 5 import java.util.GregorianCalendar;<br /> 6 <br /> 7 public class SevenNextDays {<br /> 8 <br /> 9   public static void main(String[] args) {<br />10    <br />11     // The calendar is set at the current date: today<br />12     Calendar calendar = new GregorianCalendar();<br />13 <br />14     Collection collectionOfDays = new ArrayList();<br />15     Date currentDate = new Date();<br />16     for (int i = 0; i < 7; ++i) {<br />17       // The calendar is now set to the next day<br />18       calendar.add(Calendar.DATE, 1);<br />19       currentDate.setTime(calendar.getTimeInMillis());<br />20 <br />21       collectionOfDays.add(currentDate);<br />22     }<br />23 <br />24     for (Object oneDay : collectionOfDays) {<br />25       System.out.println(\""The next day is: \"" + oneDay);<br />26     }<br />27   }<br />28 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Console for Code listing 5.2<br /><br /> The next day is: Thu Feb 4 17:03:47 UTC 2016<br /> The next day is: Thu Feb 4 17:03:47 UTC 2016<br /> The next day is: Thu Feb 4 17:03:47 UTC 2016<br /> The next day is: Thu Feb 4 17:03:47 UTC 2016<br /> The next day is: Thu Feb 4 17:03:47 UTC 2016<br /> The next day is: Thu Feb 4 17:03:47 UTC 2016<br /> The next day is: Thu Feb 4 17:03:47 UTC 2016<br /><br /><br /><br /><br /><br /><br /><br />Each collection items were said to be updated to a different date but they all have been updated to the last one. It means that each update has updated all the collection items. And this is the case. The currentDate has been used to fill all the collection items. The collection didn't keep trace of the added values (one of the seven dates) but the added object references (currentDate). So the collection contains the same object seven times! To avoid this issue, we should have coded it this way:<br /><br /><br /><br /><br /><br /><br />Code listing 5.3: ActualSevenNextDays.java<br /><br /><br /> 1 import java.util.ArrayList;<br /> 2 import java.util.Calendar;<br /> 3 import java.util.Collection;<br /> 4 import java.util.Date;<br /> 5 import java.util.GregorianCalendar;<br /> 6 <br /> 7 public class ActualSevenNextDays {<br /> 8 <br /> 9   public static void main(String[] args) {<br />10    <br />11     // The calendar is set at the current date: today<br />12     Calendar calendar = new GregorianCalendar();<br />13 <br />14     Collection collectionOfDays = new ArrayList();<br />15     for (int i = 0; i < 7; ++i) {<br />16       Date currentDate = new Date();<br />17       // The calendar is now set to the next day<br />18       calendar.add(Calendar.DATE, 1);<br />19       currentDate.setTime(calendar.getTimeInMillis());<br />20 <br />21       collectionOfDays.add(currentDate);<br />22     }<br />23 <br />24     for (Object oneDay : collectionOfDays) {<br />25       System.out.println(\""The next day is: \"" + oneDay);<br />26     }<br />27   }<br />28 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Console for Code listing 5.3<br /><br /> The next day is: Fri Jan 29 17:03:47 UTC 2016<br /> The next day is: Sat Jan 30 17:03:47 UTC 2016<br /> The next day is: Sun Jan 31 17:03:47 UTC 2016<br /> The next day is: Mon Feb 1 17:03:47 UTC 2016<br /> The next day is: Tue Feb 2 17:03:47 UTC 2016<br /> The next day is: Wed Feb 3 17:03:47 UTC 2016<br /> The next day is: Thu Feb 4 17:03:47 UTC 2016<br /><br /><br /><br /><br /><br /><br /><br />Now each time we add an item to the collection, it is a different instance. All the items evolve separately. To add an object in a collection and avoid this item to be changed each time the source object is changed, you have to copy or clone the object before you add it to the collection.<br />""]}"
"{""result"":[""/** Grades of courses */<br />  enum Grade { A, B, C, D, F };<br />  // ...<br />  private Grade gradeA = Grade.A;<br /><br /><br /><br /><br /><br />This enumeration constant then can be passed in to methods:<br /><br /><br /><br /><br /><br /><br />student.assignGrade(gradeA);<br />  /**<br />   * Assigns the grade for this course to the student<br />   * @param GRADE  Grade to be assigned<br />   */<br />  public void assignGrade(final Grade GRADE) {<br />    grade = GRADE;<br />  }<br /><br /><br /><br /><br /><br />An enumeration may also have parameters:<br /><br /><br /><br /><br /><br /><br />public enum DayOfWeek {<br />  /** Enumeration constants */<br />  MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(0);<br /><br />  /** Code for the days of the week */<br />  private byte dayCode = 0;<br /><br />  /**<br />   * Private constructor<br />   * @param VALUE  Value that stands for a day of the week.<br />   */<br />  private DayOfWeek(final byte VALUE) {<br />    dayCode = java.lang.Math.abs(VALUE%7);<br />  }<br /> <br />  /**<br />   * Gets the day code<br />   * @return  The day code<br />   */<br />  public byte getDayCode() {<br />    return dayCode;<br />  }<br />}<br /><br /><br /><br /><br /><br />It is also possible to let an enumeration implement interfaces other than java.lang.Comparable and java.io.Serializable, which are already implicitly implemented by each enumeration:<br /><br /><br /><br /><br /><br /><br />public enum DayOfWeek implements Runnable {<br />  MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;<br /> <br />  /**<br />   * Run method prints all elements<br />   */<br />  public void run() {<br />    System.out.println(\""name() = \"" + name() +<br />      \"", toString() = \\\""\"" + toString() + \""\\\""\"");<br />  }<br />}<br />"",""To easily remember what can be done in method overriding, keep in mind that all you can do on an object of a class outside this class, you can do it also on an object of a subclass, only the behavior can change. A subclass should be covariant.<br />Although a method signature has to be unique inside a class, the same method signature can be defined in different classes. If we define a method that exists in the super class then we override the super class method. It is called method overriding. This is different from method overloading. Method overloading happens with methods with the same name different signature. Method overriding happens with same name, same signature between inherited classes.<br />The return type can cause the same problem we saw above. When we override a super class method the return type also must be the same. If that is not the same, the compiler will give you an error.<br />Beware! If a class declares two public methods with the same name, and a subclass overrides one of them, the subclass still inherits the other method. In this respect, the Java programming language differs from C++.<br />Method overriding is related dynamic linking, or runtime binding. In order for the Method Overriding to work, the method call that is going to be called can not be determined at compilation time. It will be decided at runtime, and will be looked up in a table.<br /><br /><br /><br />Code section 4.31: Runtime binding.<br /><br /><br /> 1 MyClass obj;<br /> 2 <br /> 3 if (new java.util.Calendar().get(java.util.Calendar.AM_PM) == java.util.Calendar.AM) {<br /> 4   // Executed a morning<br /> 5   obj = new SubOfMyClass();<br /> 6 } else {<br /> 7   // Executed an afternoon<br /> 8   obj = new MyClass();<br /> 9 }<br />10  <br />11 obj.myMethod();<br /><br /><br /><br /><br /><br />In the code section 4.31, the expression at line 3 is true if it is executed a morning and false if it is executed an afternoon. Thus, the instance of obj will be a MyClass or a SubOfMyClass depending on the execution time. So it is impossible to determine the method address at compile time. Because the obj reference can point to object and all its sub object, and that will be known only at runtime, a table is kept with all the possible method addresses to be called. Do not confuse:<br /><br /><br /><br />Code section 4.32: Declared type and instantiated type.<br /><br /><br />1 obj.myMethod(myParameter);<br /><br /><br /><br /><br />The implementation of this method is searched using the instantiated type of the called object (obj) and the declared type of the parameter object (myParameter).<br />Also another rule is that when you do an override, the visibility of the new method that overrides the super class method can not be reduced. The visibility can be increased, however. So if the super class method visibility is public, the override method can not be package, or private. An override method must throw the same exceptions as the super class, or their subexceptions.<br />super references to the parent class (i.e. super.someMethod()). It can be used in a subclass to access inherited methods that the subclass has overridden or inherited fields that the subclass has hidden.<br /><br /><br /><br />A common mistake to think that if we can override methods, we could also override member variables. This is not the case, as it is useless. You can redefine a variable that is private in the super class as such a variable is not visible.<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />To do:<br />Add some exercises like the ones in Variables<br /><br /><br /><br /><br /><br /><br /> Interfaces<br />Java Programming<br />Overloading Methods and Constructors<br />Object Lifecycle<br />"",""If you have objects from different classes that do not have common superclasses, you can't call a same method on them, even if the two classes implement a method with the same signature.<br /><br /><br /><br />Code listing 4.16: OneClass.java<br /><br /><br />1 public class OneClass {<br />2     public int method1(String parameter) {<br />3         return 1;<br />4     }<br />5 }<br /><br /><br /><br /><br /><br /><br /><br />Code listing 4.17: AnotherClass.java<br /><br /><br />1 public class AnotherClass {<br />2     public int method1(String parameter) {<br />3         return 2;<br />4     }<br />5 }<br /><br /><br /><br /><br /><br /><br /><br />Code section 4.16: Impossible call.<br /><br /><br />1 public static void main(String[] args) {<br />2     doAction(new OneClass());<br />3     doAction(new AnotherClass());<br />4 }<br />5 <br />6 public void doAction(Object anObject) {<br />7     anObject.method1(\""Hello!\"");<br />8 }<br /><br /><br /><br /><br />The solution is to write an interface that defines the method that should be implemented in the two classes as the SimpleInterface in the Code listing 4.14 and then the both class implement the interface as in the Code listing 4.15.<br /><br /><br /><br />Code section 4.17: Interface use.<br /><br /><br />1 public static void main(String[] args) {<br />2     doAction(new ClassWithInterface());<br />3     doAction(new AnotherClassWithInterface());<br />4 }<br />5 <br />6 public void doAction(SimpleInterface anObject) {<br />7     anObject.method1(\""Hello!\"");<br />8 }<br /><br /><br /><br /><br />You can also have this interest using a common super class but a class can only inherit from one super class whereas it can implement several interfaces. Java does not support full orthogonal multiple inheritance. Java does not allow you to create a subclass from two classes. Multiple inheritance in C++ has complicated rules to disambiguate fields and methods inherited from multiple superclasses and types inherited multiple times. By separating interface from implementation, interfaces offer much of the benefit of multiple inheritance with less complexity and ambiguity. The price of no multiple inheritance is some code redundancy; since interfaces only define the signature of a class but cannot contain any implementation, every class inheriting an interface must provide the implementation of the defined methods, unlike in pure multiple inheritance, where the implementation is also inherited. The major benefit of that is that all Java objects can have a common ancestor. That class is called Object. When overriding methods defined in interfaces there are several rules to be followed:<br /><br />Checked exceptions should not be declared on implementation methods other than the ones declared by the interface method or subclasses of those declared by the interface method.<br />The signature of the interface method and the same return type or subtype should be maintained when implementing the methods.<br />All the methods of the interface need to be defined in the class, unless the class that implements the interface is abstract.<br />"",""public is a Java keyword which declares a member's access as public. Public members are visible to all other classes. This means that any other class can access a public field or method. Further, other classes can modify public fields unless the field is declared as final.<br />A best practice is to give fields private access and reserve public access to only the set of methods and final fields that define the class' public constants. This helps with encapsulation and information hiding, since it allows you to change the implementation of a class without affecting the consumers who use only the public API of the class.<br />Below is an example of an immutable public class named Length which maintains private instance fields named units and magnitude but provides a public constructor and two public accessor methods.<br /><br /><br /><br />Code listing: Length.java<br /><br /><br /> 1 package org.wikibooks.java;<br /> 2 <br /> 3 public class Length {<br /> 4    private double magnitude;<br /> 5    private String units;<br /> 6 <br /> 7    public Length(double magnitude, String units) {<br /> 8       if ((units == null) || (units.trim().length() == 0)) {<br /> 9           throw new IllegalArgumentException(\""non-null, non-empty units required.\"");<br />10       }<br />11 <br />12       this.magnitude = magnitude;<br />13       this.units = units;<br />14    }<br />15 <br />16    public double getMagnitude() {<br />17       return magnitude;<br />18    }<br />19 <br />20    public String getUnits() {<br />21       return units;<br />22    }<br />23 }<br />"",""At the instantiating, the child class receives the features inherited from its superclass, which also has received the features inherited from its own superclass and so on to the Object class. This mechanism allows to define reusable global classes, whose user details the behavior in the derived more specific classes.<br />In Java, a class can only inherit from one class. Java does not allow you to create a subclass from two classes, as that would require creating complicated rules to disambiguate fields and methods inherited from multiple superclasses. If there is a need for Java to inherit from multiple sources, the best option is through interfaces, described in the next chapter.<br />"",""In Java and J2EE programming, you can call a method on an object only if it is casted to a class or an interface that declares it. The structured definition of bean properties is very useful for comparing a single common property across several objects that are not and should not be related by inheritance.<br />For example, a program may contain both a bean representing a company's employees, and another containing a list of buildings that a company occupies. A programmer writing a function called listAssetNames() wants to write a simple way of getting the field \""name\"" from several beans that can get the field from both Employee and Building beans, and that can be easily adapted to get the same field from other types of beans that may not be written yet.<br />While this could be done by rewriting both Employee and Building so that they each inherit from one class named NamedObject, or by creating a NamedObject interface, both methods have their own problems. Using inheritance is limiting, as each child class can only inherit from one parent class, which limits the number of different classes that can share properties, as well as the number of common properties that can be shared. Furthermore, using inheritance to express relationships other than a simple \""is-a\"" relationship can be confusing, as can looking through dozens of class definitions to find where a single \""dumb\"" getter function is implemented. Creating an interface fixes the problems caused by the multiple inheritance rule, as a class can use any number of interfaces, but it still requires every shared property to be explicitly spelled out.<br />The simplest, most elegant way to deal with this type of relationship is to read the bean properties using introspection. The jakarta BeanUtils package is a common way of handling objects that need to be related in this way, as it takes advantage of the regularity of JavaBean naming conventions.<br /><br /><br /><br />Code listing 9.13: Get property from a JavaBean<br /><br /><br /> 1 public static Object getProperty(Object o, String propertyName) {<br /> 2    if (o == null ||<br /> 3        propertyName == null ||<br /> 4        propertyName.length() < 1) {<br /> 5       return null;<br /> 6    }<br /> 7    // Based on the property name build the getter method name<br /> 8    String methodName = \""get\"" +<br /> 9                       propertyName.substring(0,1).toUpperCase() +<br />10                       propertyName.substring(1);<br />11    Object property = null;<br />12    try {<br />13       java.lang.Class c = o.getClass();<br />14       java.lang.reflect.Method m = c.getMethod(methodName, null);<br />15       property = m.invoke(o, null);<br />16    } catch (NoSuchMethodException e) {<br />17      // Handle exception<br />18    }  catch (SecurityException e) {<br />19      // No permission; Handle exception<br />20    }<br />21 return property;<br />22 }<br /><br /><br /><br /><br />or<br /><br /><br /><br />Code listing 9.14: Use Apache Commons BeanUtils<br /><br /><br /> 1 import org.apache.commons.beanutils.PropertyUtils;<br /> 2 <br /> 3 try {<br /> 4   Object myValue = PropertyUtils.getSimpleProperty(o, propertyName);<br /> 5 } catch (IllegalAccessException e) {<br /> 6   // Handle exception<br /> 7 } catch (InvocationTargetException e) {<br /> 8   // Handle exception<br /> 9 } catch (NoSuchMethodException e) {<br />10   // Handle exception<br />11 }<br />"",""Different annotation types have different purposes. Some are intended for use with the compiler; others are meant to be reflected dynamically at runtime. There's no reason for a compiler annotation to be available at runtime, so the @Retention meta-annotation specifies how long an annotation type should be retained. The value attribute is one of the java.lang.annotation.RetentionPolicy enum constants. The possible values, in order from shortest to longest retention, are as follows:<br /><br />RetentionPolicy.SOURCE<br />The annotation will not be included in the class file. This is useful for annotations which are intended for the compiler only.<br />RetentionPolicy.CLASS<br />The annotation will be included in the class file, but cannot be read reflectively.<br />RetentionPolicy.RUNTIME<br />The annotation can be reflected at runtime.<br /><br />If no @Retention policy is specified, it defaults to RetentionPolicy.CLASS.<br />"",""Next, let's take a look at applying an adaptor to our design. Adaptors are used to add functionality to the event handling process that:<br /><br />is general to the process and not specific to any one listener; or<br />is not supposed to affect the implementation of specific listeners.<br /><br />According to the Event Model specification a typical use case for an adaptor is to add routing logic for events. But you can also add filtering or logging. In our case, let's do that: add logging of the numbers as \""proof\"" for the calculations done in the listeners.<br />An adaptor, as explained earlier, is a class that sits between the event source and the listeners. From the point of view of the event source, it masquerades as a listener (so it must implement the listener interface). From the point of view of the listeners it pretends to be the event source (so it should have add and remove methods). In other words, to write an adaptor you have to repeat some code from the event source (to manage listeners) and you have to re-implement the event notification methods to do some extra stuff and then pass the event on to the actual listeners.<br />In our case we need an adaptor that writes the numbers to a log file. Keeping it simple once again, let's settle for an adaptor that:<br /><br />Uses a fixed log file name and overwrites that log file with every program run.<br />Opens a FileWriter in the constructor and just keeps it open.<br />Implements the numberRead method by writing the number to the FileWriter.<br />Implements the numberStreamTerminated method by closing the FileWriter.<br /><br />Also, we can make life easy on ourselves by just copying all the code we need to manage listeners over from the NumberReader class. Again, in a real program you'd want to do this differently. Note that each notification method implementation also passes the event on to all the real listeners:<br /><br /><br /><br />Code listing 1.6: NumberReaderLoggingAdaptor.<br /><br /><br />package org.wikibooks.en.javaprogramming.example;<br /><br />import java.io.BufferedWriter;<br />import java.io.FileWriter;<br />import java.io.IOException;<br />import java.util.HashSet;<br />import java.util.Set;<br /><br />public class NumberReaderLoggingAdaptor implements NumberReadListener {<br />    private Set<NumberReadListener> listeners;<br />    private BufferedWriter output;<br />   <br />    public NumberReaderLoggingAdaptor() {<br />        listeners = new HashSet<NumberReadListener>();<br />        try {<br />            output = new BufferedWriter(new FileWriter(\""numberLog.log\""));<br />        } catch (IOException e) {<br />            // TODO Auto-generated catch block<br />            e.printStackTrace();<br />        }<br />    }<br />   <br />    public void addNumberReadListener(NumberReadListener listener) {<br />        this.listeners.add(listener);<br />    }<br />   <br />    public void removeNumberReadListener(NumberReadListener listener) {<br />        this.listeners.remove(listener);<br />    }<br />   <br />   <br />    @Override<br />    public void numberRead(NumberReadEvent numberReadEvent) {<br />        try {<br />            output.write(numberReadEvent.getNumber() + \""\\n\"");<br />        } catch (Exception e) {<br />           <br />        }<br />        for (NumberReadListener numberReadListener: listeners) {<br />            numberReadListener.numberRead(numberReadEvent);<br />        }<br />    }<br /><br />    @Override<br />    public void numberStreamTerminated(NumberReadEvent numberReadEvent) {<br />        try {<br />            output.flush();<br />            output.close();<br />        } catch (Exception e) {<br />           <br />        }<br />        for (NumberReadListener numberReadListener: listeners) {<br />            numberReadListener.numberStreamTerminated(numberReadEvent);<br />        }<br />    }<br /><br />}<br /><br /><br /><br /><br />Of course, to make the adaptor work we have to make some changes to the bootstrap code:<br /><br /><br /><br />Code listing 1.7: Main.<br /><br /><br />package org.wikibooks.en.javaprogramming.example;<br /><br />public class Main {<br /><br />    public static void main(String[] args) {<br />        NumberReader reader = new NumberReader();<br />        NumberReadListener listener = new NumberReadListenerImpl();<br />        NumberReaderLoggingAdaptor adaptor = new NumberReaderLoggingAdaptor();<br />        adaptor.addNumberReadListener(listener);<br />        reader.addNumberReadListener(adaptor);<br />        reader.start();<br />    }<br />}<br /><br /><br /><br /><br />But note how nicely and easily we can re-link the objects in our system. The fact that adaptors and listeners both implement the listener interface and the adaptor and event source both look like event sources means that we can hook the adaptor into the system without having to change a single statement in the classes that we developed earlier.<br />And of course, if we run the same example as given above, the numbers are now recorded in a log file.<br />"",""Let's start with the basics. According to the Event Model rules, we must define an event class to encapsulate our interesting event. We should call this class something-somethingEvent. Let's go for NumberReadEvent, since that's what will interest us. According to the Model rules, this class should encapsulate any state that belongs with an event occurrence. In our case, that's the number read from the stream. And our event class must inherit from java.util.EventObject. So all in all, the following class is all we need:<br /><br /><br /><br />Code listing 1.1: NumberReadEvent.<br /><br /><br />package org.wikibooks.en.javaprogramming.example;<br /><br />import java.util.EventObject;<br /><br />public class NumberReadEvent extends EventObject {<br /><br />    private Double number;<br />   <br />    public NumberReadEvent(Object source, Double number) {<br />        super(source);<br />        this.number = number;<br />    }<br /><br />    public Double getNumber() {<br />        return number;<br />    }<br />}<br /><br /><br /><br /><br />Next, we must define a listener interface. This interface must define methods for interesting events and must extend java.util.EventListener. We said earlier our interesting events were \""number read\"" and \""end of stream reached\"", so here we go:<br /><br /><br /><br />Code listing 1.2: NumberReadListener.<br /><br /><br />package org.wikibooks.en.javaprogramming.example;<br /><br />import java.util.EventListener;<br /><br />public interface NumberReadListener extends EventListener {<br />    public void numberRead(NumberReadEvent numberReadEvent);<br />   <br />    public void numberStreamTerminated(NumberReadEvent numberReadEvent);<br />}<br /><br /><br /><br /><br />Actually the numberStreamTerminated method is a little weird, since it isn't actually a \""number read\"" event. In a real program you'd probably want to do this differently. But let's keep things simple in this example.<br />"",""The basic Event Model framework<br /><br /><br />The Event Model framework is really very simple in and of itself, consisting of three classes (one abstract) and an interface. Most of all it consists of naming conventions that the programmer must obey. The framework is depicted in the image on the right.<br />Speaking in terms of classes and interfaces, the most important parts of the framework are the java.util.EventObject abstract class and the java.util.EventListener interface. These two types are the centerpieces of the rules and conventions of the Java Platform Event Model, which are:<br /><br />A class that has to be notified when an event occurs, is called an event listener. An event listener has one distinct method for each type of event notification that it is interested in.<br />Event notification method declarations are grouped together into categories. Each category is represented by an event listener interface, which must extend java.util.EventListener. By convention an event listener interface is named <Event category name>Listener. Any class that will be notified of events must implement at least one listener interface.<br />Any and all state related to an event occurrence will be captured in a state object. The class of this object must be a subclass of java.util.EventObject and must record at least which object was the source of the event. Such a class is called an event class and by convention is named <Event category name>Event.<br />Usually (but not necessarily!) an event listener interface will relate to a single event class. An event listener may have multiple event notification methods that take the same event class as an argument.<br />An event notification method usually (but not necessarily!) has the conventional signature public void <specific event>(<Event category name>Event evt).<br />A class that is the source of events must have a method that allows for the registration of listeners, one for each possible listener interface type. These methods must by convention have the signature public void add<Event category name>Listener(<Event category name>Listener listener).<br />A class that is the source of events may have a method that allows for the deregistration of listeners, one for each possible listener interface type. These methods must by convention have the signature public void remove<Event category name>Listener(<Event category name>Listener listener).<br /><br /><br /><br /><br /><br />A general example of how the framework is used<br /><br /><br />That seems like a lot, but it's pretty simple once you get used to it. Take a look at the image on the left, which contains a general example of how you might use the framework. In this example we have a class called EventSourceClass that publishes interesting events. Following the rules of the Event Model, the events are represented by the InterestingEvent class which has a reference back to the EventSourceClass object (source, inherited from java.util.EventObject).<br />Whenever an interesting event occurs, the EventSourceClass must notify all of the listeners for that event that it knows about by calling the notification method that exist for that purpose. All of the notification methods (in this example there is only one, interestingEventOccurred) have been grouped together by topic in a listener interface: InterestingEventListener, which implements java.util.EventListener and is named according to the Event Model conventions. This interface must be implemented by all event listener classes (in this case only InterestingEventListenerImpl). Because EventSourceClass must be able to notify any interested listeners, it must be possible to register them. For this purpose the EventSourceClass has an addInterestingEventListener method. And since it is required, there is a removeInterestingEventListener method as well.<br />As you can clearly see from the example, using the Event Model is mostly about following naming conventions. This might seem a little cumbersome at first, but the point of having naming conventions is to allow automated tooling to access and use the event model. And there are indeed many tools, IDEs and frameworks that are based on these naming conventions.<br />""]}"
"{""result"":[""Java SE 5.0 added syntactic support for methods with variable argument list, which simplifies the typesafe usage of methods requiring a variable number of arguments. Less formally, these parameters are called varargs[1]. The last parameter can be followed with ..., and Java will box all the arguments into an array. Vararg parameter must always be the last method parameter:<br /><br /><br /><br />Code section 3.76: A method using vararg parameters.<br /><br /><br />1 public void drawPolygon(java.awt.Point... points) {<br />2   //…<br />3 }<br /><br /><br /><br /><br />When calling the method, a programmer can simply separate the points by commas, without having to explicitly create an array of Point objects. Within the method, the points can be referenced as points[0], points[1], etc. If no points are passed, the array has a length of zero. To require the programmer to use a minimum number of parameters, those parameters can be specified before the variable argument:<br /><br /><br /><br />Code section 3.77: Variable arguments.<br /><br /><br />1 // A polygon needs at least three points.<br />2 public void drawPolygon(Point p1, Point p2, Point p3, Point... otherPoints) {…}<br />"",""In Java and J2EE programming, you can call a method on an object only if it is casted to a class or an interface that declares it. The structured definition of bean properties is very useful for comparing a single common property across several objects that are not and should not be related by inheritance.<br />For example, a program may contain both a bean representing a company's employees, and another containing a list of buildings that a company occupies. A programmer writing a function called listAssetNames() wants to write a simple way of getting the field \""name\"" from several beans that can get the field from both Employee and Building beans, and that can be easily adapted to get the same field from other types of beans that may not be written yet.<br />While this could be done by rewriting both Employee and Building so that they each inherit from one class named NamedObject, or by creating a NamedObject interface, both methods have their own problems. Using inheritance is limiting, as each child class can only inherit from one parent class, which limits the number of different classes that can share properties, as well as the number of common properties that can be shared. Furthermore, using inheritance to express relationships other than a simple \""is-a\"" relationship can be confusing, as can looking through dozens of class definitions to find where a single \""dumb\"" getter function is implemented. Creating an interface fixes the problems caused by the multiple inheritance rule, as a class can use any number of interfaces, but it still requires every shared property to be explicitly spelled out.<br />The simplest, most elegant way to deal with this type of relationship is to read the bean properties using introspection. The jakarta BeanUtils package is a common way of handling objects that need to be related in this way, as it takes advantage of the regularity of JavaBean naming conventions.<br /><br /><br /><br />Code listing 9.13: Get property from a JavaBean<br /><br /><br /> 1 public static Object getProperty(Object o, String propertyName) {<br /> 2    if (o == null ||<br /> 3        propertyName == null ||<br /> 4        propertyName.length() < 1) {<br /> 5       return null;<br /> 6    }<br /> 7    // Based on the property name build the getter method name<br /> 8    String methodName = \""get\"" +<br /> 9                       propertyName.substring(0,1).toUpperCase() +<br />10                       propertyName.substring(1);<br />11    Object property = null;<br />12    try {<br />13       java.lang.Class c = o.getClass();<br />14       java.lang.reflect.Method m = c.getMethod(methodName, null);<br />15       property = m.invoke(o, null);<br />16    } catch (NoSuchMethodException e) {<br />17      // Handle exception<br />18    }  catch (SecurityException e) {<br />19      // No permission; Handle exception<br />20    }<br />21 return property;<br />22 }<br /><br /><br /><br /><br />or<br /><br /><br /><br />Code listing 9.14: Use Apache Commons BeanUtils<br /><br /><br /> 1 import org.apache.commons.beanutils.PropertyUtils;<br /> 2 <br /> 3 try {<br /> 4   Object myValue = PropertyUtils.getSimpleProperty(o, propertyName);<br /> 5 } catch (IllegalAccessException e) {<br /> 6   // Handle exception<br /> 7 } catch (InvocationTargetException e) {<br /> 8   // Handle exception<br /> 9 } catch (NoSuchMethodException e) {<br />10   // Handle exception<br />11 }<br />"",""The basic Event Model framework<br /><br /><br />The Event Model framework is really very simple in and of itself, consisting of three classes (one abstract) and an interface. Most of all it consists of naming conventions that the programmer must obey. The framework is depicted in the image on the right.<br />Speaking in terms of classes and interfaces, the most important parts of the framework are the java.util.EventObject abstract class and the java.util.EventListener interface. These two types are the centerpieces of the rules and conventions of the Java Platform Event Model, which are:<br /><br />A class that has to be notified when an event occurs, is called an event listener. An event listener has one distinct method for each type of event notification that it is interested in.<br />Event notification method declarations are grouped together into categories. Each category is represented by an event listener interface, which must extend java.util.EventListener. By convention an event listener interface is named <Event category name>Listener. Any class that will be notified of events must implement at least one listener interface.<br />Any and all state related to an event occurrence will be captured in a state object. The class of this object must be a subclass of java.util.EventObject and must record at least which object was the source of the event. Such a class is called an event class and by convention is named <Event category name>Event.<br />Usually (but not necessarily!) an event listener interface will relate to a single event class. An event listener may have multiple event notification methods that take the same event class as an argument.<br />An event notification method usually (but not necessarily!) has the conventional signature public void <specific event>(<Event category name>Event evt).<br />A class that is the source of events must have a method that allows for the registration of listeners, one for each possible listener interface type. These methods must by convention have the signature public void add<Event category name>Listener(<Event category name>Listener listener).<br />A class that is the source of events may have a method that allows for the deregistration of listeners, one for each possible listener interface type. These methods must by convention have the signature public void remove<Event category name>Listener(<Event category name>Listener listener).<br /><br /><br /><br /><br /><br />A general example of how the framework is used<br /><br /><br />That seems like a lot, but it's pretty simple once you get used to it. Take a look at the image on the left, which contains a general example of how you might use the framework. In this example we have a class called EventSourceClass that publishes interesting events. Following the rules of the Event Model, the events are represented by the InterestingEvent class which has a reference back to the EventSourceClass object (source, inherited from java.util.EventObject).<br />Whenever an interesting event occurs, the EventSourceClass must notify all of the listeners for that event that it knows about by calling the notification method that exist for that purpose. All of the notification methods (in this example there is only one, interestingEventOccurred) have been grouped together by topic in a listener interface: InterestingEventListener, which implements java.util.EventListener and is named according to the Event Model conventions. This interface must be implemented by all event listener classes (in this case only InterestingEventListenerImpl). Because EventSourceClass must be able to notify any interested listeners, it must be possible to register them. For this purpose the EventSourceClass has an addInterestingEventListener method. And since it is required, there is a removeInterestingEventListener method as well.<br />As you can clearly see from the example, using the Event Model is mostly about following naming conventions. This might seem a little cumbersome at first, but the point of having naming conventions is to allow automated tooling to access and use the event model. And there are indeed many tools, IDEs and frameworks that are based on these naming conventions.<br />"",""Released on 11 December 2006.[4]<br />What's New in Java SE 6:<br /><br />Web Services - First-class support for writing XML web service client applications.<br /><br /><br />Scripting - You can now mix in JavaScript technology source code, useful for prototyping. Also useful when you have teams with a variety of skill sets. More advanced developers can plug in their own scripting engines and mix their favorite scripting language in with Java code as they see fit.<br /><br /><br />Database - No more need to find and configure your own JDBC database when developing a database application. Developers will also get the updated JDBC 4.0, a well-used API with many important improvements, such as special support for XML as an SQL datatype and better integration of Binary Large OBjects (BLOBs) and Character Large OBjects (CLOBs) into the APIs.<br /><br /><br />More Desktop APIs - GUI developers get a large number of new tricks to play like the ever popular yet newly incorporated SwingWorker utility to help you with threading in GUI apps, JTable sorting and filtering, and a new facility for quick splash screens to quiet impatient users.<br /><br /><br />Monitoring and Management - The really big deal here is that you don't need to do anything special to the startup to be able to attach on demand with any of the monitoring and management tools in the Java SE platform.<br /><br /><br />Compiler Access - Really aimed at people who create tools for Java development and for frameworks like JavaServer Pages (JSP) or Personal Home Page construction kit (PHP) engines that need to generate a bunch of classes on demand, the compiler API opens up programmatic access to javac for in-process compilation of dynamically generated Java code. The compiler API is not directly intended for the everyday developer, but for those of you deafened by your screaming inner geek, roll up your sleeves and give it a try. And the rest of us will happily benefit from the tools and the improved Java frameworks that use this.<br /><br /><br />Pluggable Annotations allows programmer to write annotation processor so that it can analyse your code semantically before javac compiles. For example, you could write an annotation processor that verifies whether your program obeys naming conventions.<br /><br /><br />Desktop Deployment - At long last, Java SE 6 unifies the Java Plug-in technology and Java WebStart engines, which just makes sense. Installation of the Java WebStart application got a much needed makeover.<br /><br /><br />Security - Java SE 6 has simplified the job of its security administrators by providing various new ways to access platform-native security services, such as native Public Key Infrastructure (PKI) and cryptographic services on Microsoft Windows for secure authentication and communication, Java Generic Security Services (Java GSS) and Kerberos services for authentication, and access to LDAP servers for authenticating users.<br /><br /><br />The -lities: Quality, Compatibility, Stability - Bug fixes ...<br />"",""In C or C++ programming, you start to write a source code:<br /><br />... you compile it to a machine code file:<br /> <br />... and then you execute it:<br />  <br />In this situation, the machine code file and its execution are specific to the platform (Windows, Linux, Mac OS, ...) it was compiled for, that is to say to the targeted platform:<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />... because the compiled file is a machine code file designed to work on a specific platform and hardware. It would have produced a different results/output for another platform. So if you want your program to run on several platforms, you have to compile your program several times:<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />It poses greater vulnerability risks. Note here that when a certain code is compiled into an executable format, the executable cannot be changed dynamically. It would need to be recompiled from the changed code for the changes to be reflected in the finished executable. Modularity (dividing code into modules) is not present in Java's predecessors. If instead of a single executable, the output application was in the form of modules, one could easily change a single module and review changes in the application. In C/C++ on the other hand, a slight change in code required the whole application to be recompiled.<br />The idea of Java is to compile the source code into an intermediate language that will be interpreted.<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />The source code<br />The intermediate file<br />The interpretor<br /><br /><br />The intermediate language is the byte code. The interpretor is the Java Virtual Machine (JVM). The byte code file is universal and the JVM is platform specific:<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />So a JVM should be coded for each platform. And that's the case. So you just have to generate a unique byte code file (a .class file).<br />The first implementations of the language used an interpreted virtual machine to achieve portability, and many implementations still do. These implementations produce programs that run more slowly than the fully-compiled programs created by the typical C++ compiler, so the language suffered a reputation for producing slow programs. Since Java 1.2, Java VM produces programs that run much faster, using multiple techniques.<br />The first of these is to simply compile directly into native code like a more traditional compiler, skipping bytecode entirely. This achieves great performance, but at the expense of portability. This is not really used any more.<br />Another technique, the just-in-time (JIT) compiler, compiles the Java bytecode into native code at the time the program is run, and keep the compiled code to be used again and again. More sophisticated VMs even use dynamic recompilation, in which the VM can analyze the behavior of the running program and selectively recompile and optimize critical parts of the program. Both of these techniques allow the program to take advantage of the speed of native code without losing portability.<br />Portability is a technically difficult goal to achieve, and Java's success at that goal is a matter of some controversy. Although it is indeed possible to write programs for the Java platform that behave consistently across many host platforms, the large number of available platforms with small errors or inconsistencies led some to parody Sun's \""Write once, run anywhere\"" slogan as \""Write once, debug everywhere\"".<br />"",""Instead of overloading, you can use dynamic number of arguments. After the last parameter, you can pass optional unlimited parameters of the same type. These parameters are defined by adding a last parameter and adding ... after its type. The dynamic arguments will be received as an array:<br /><br /><br /><br />Code section 4.27: Variable argument.<br /><br /><br /> 1   public void registrerPersonInAgenda(String firstName, String lastName, Date... meeting) {<br /> 2     String[] person = {firstName, lastName};<br /> 3     lastPosition = lastPosition + 1;<br /> 4     contactArray[lastPosition] = person;<br /> 5 <br /> 6     if (meeting.length > 0) {<br /> 7       Date[] temporaryMeetings = registreredMeetings.length + meeting.length;<br /> 8       for (i = 0; i < registreredMeetings.length; i++) {<br /> 9         temporaryMeetings[i] = registreredMeetings[i];<br />10       }<br />11       for (i = 0; i < meeting.length; i++) {<br />12         temporaryMeetings[registreredMeetings.length + i] = meeting[i];<br />13       }<br />14       registreredMeetings = temporaryMeetings;<br />15     }<br />16   }<br /><br /><br /><br /><br />The above method can be called with a dynamic number of arguments, for example:<br /><br /><br /><br />Code section 4.27: Constructor calls.<br /><br /><br />1 registrerPersonInAgenda(\""John\"", \""Doe\"");<br />2 registrerPersonInAgenda(\""Mark\"", \""Lee\"", new Date(), new Date());<br /><br /><br /><br /><br />This feature was not available before Java 1.5 .<br />"",""To easily remember what can be done in method overriding, keep in mind that all you can do on an object of a class outside this class, you can do it also on an object of a subclass, only the behavior can change. A subclass should be covariant.<br />Although a method signature has to be unique inside a class, the same method signature can be defined in different classes. If we define a method that exists in the super class then we override the super class method. It is called method overriding. This is different from method overloading. Method overloading happens with methods with the same name different signature. Method overriding happens with same name, same signature between inherited classes.<br />The return type can cause the same problem we saw above. When we override a super class method the return type also must be the same. If that is not the same, the compiler will give you an error.<br />Beware! If a class declares two public methods with the same name, and a subclass overrides one of them, the subclass still inherits the other method. In this respect, the Java programming language differs from C++.<br />Method overriding is related dynamic linking, or runtime binding. In order for the Method Overriding to work, the method call that is going to be called can not be determined at compilation time. It will be decided at runtime, and will be looked up in a table.<br /><br /><br /><br />Code section 4.31: Runtime binding.<br /><br /><br /> 1 MyClass obj;<br /> 2 <br /> 3 if (new java.util.Calendar().get(java.util.Calendar.AM_PM) == java.util.Calendar.AM) {<br /> 4   // Executed a morning<br /> 5   obj = new SubOfMyClass();<br /> 6 } else {<br /> 7   // Executed an afternoon<br /> 8   obj = new MyClass();<br /> 9 }<br />10  <br />11 obj.myMethod();<br /><br /><br /><br /><br /><br />In the code section 4.31, the expression at line 3 is true if it is executed a morning and false if it is executed an afternoon. Thus, the instance of obj will be a MyClass or a SubOfMyClass depending on the execution time. So it is impossible to determine the method address at compile time. Because the obj reference can point to object and all its sub object, and that will be known only at runtime, a table is kept with all the possible method addresses to be called. Do not confuse:<br /><br /><br /><br />Code section 4.32: Declared type and instantiated type.<br /><br /><br />1 obj.myMethod(myParameter);<br /><br /><br /><br /><br />The implementation of this method is searched using the instantiated type of the called object (obj) and the declared type of the parameter object (myParameter).<br />Also another rule is that when you do an override, the visibility of the new method that overrides the super class method can not be reduced. The visibility can be increased, however. So if the super class method visibility is public, the override method can not be package, or private. An override method must throw the same exceptions as the super class, or their subexceptions.<br />super references to the parent class (i.e. super.someMethod()). It can be used in a subclass to access inherited methods that the subclass has overridden or inherited fields that the subclass has hidden.<br /><br /><br /><br />A common mistake to think that if we can override methods, we could also override member variables. This is not the case, as it is useless. You can redefine a variable that is private in the super class as such a variable is not visible.<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />To do:<br />Add some exercises like the ones in Variables<br /><br /><br /><br /><br /><br /><br /> Interfaces<br />Java Programming<br />Overloading Methods and Constructors<br />Object Lifecycle<br />"",""If you have objects from different classes that do not have common superclasses, you can't call a same method on them, even if the two classes implement a method with the same signature.<br /><br /><br /><br />Code listing 4.16: OneClass.java<br /><br /><br />1 public class OneClass {<br />2     public int method1(String parameter) {<br />3         return 1;<br />4     }<br />5 }<br /><br /><br /><br /><br /><br /><br /><br />Code listing 4.17: AnotherClass.java<br /><br /><br />1 public class AnotherClass {<br />2     public int method1(String parameter) {<br />3         return 2;<br />4     }<br />5 }<br /><br /><br /><br /><br /><br /><br /><br />Code section 4.16: Impossible call.<br /><br /><br />1 public static void main(String[] args) {<br />2     doAction(new OneClass());<br />3     doAction(new AnotherClass());<br />4 }<br />5 <br />6 public void doAction(Object anObject) {<br />7     anObject.method1(\""Hello!\"");<br />8 }<br /><br /><br /><br /><br />The solution is to write an interface that defines the method that should be implemented in the two classes as the SimpleInterface in the Code listing 4.14 and then the both class implement the interface as in the Code listing 4.15.<br /><br /><br /><br />Code section 4.17: Interface use.<br /><br /><br />1 public static void main(String[] args) {<br />2     doAction(new ClassWithInterface());<br />3     doAction(new AnotherClassWithInterface());<br />4 }<br />5 <br />6 public void doAction(SimpleInterface anObject) {<br />7     anObject.method1(\""Hello!\"");<br />8 }<br /><br /><br /><br /><br />You can also have this interest using a common super class but a class can only inherit from one super class whereas it can implement several interfaces. Java does not support full orthogonal multiple inheritance. Java does not allow you to create a subclass from two classes. Multiple inheritance in C++ has complicated rules to disambiguate fields and methods inherited from multiple superclasses and types inherited multiple times. By separating interface from implementation, interfaces offer much of the benefit of multiple inheritance with less complexity and ambiguity. The price of no multiple inheritance is some code redundancy; since interfaces only define the signature of a class but cannot contain any implementation, every class inheriting an interface must provide the implementation of the defined methods, unlike in pure multiple inheritance, where the implementation is also inherited. The major benefit of that is that all Java objects can have a common ancestor. That class is called Object. When overriding methods defined in interfaces there are several rules to be followed:<br /><br />Checked exceptions should not be declared on implementation methods other than the ones declared by the interface method or subclasses of those declared by the interface method.<br />The signature of the interface method and the same return type or subtype should be maintained when implementing the methods.<br />All the methods of the interface need to be defined in the class, unless the class that implements the interface is abstract.<br />"",""Released on 28 July 2011.<br />Feature additions for Java 7 include:[5]<br /><br />JVM support for dynamic languages, following the prototyping work currently done on the Multi Language Virtual Machine<br />Compressed 64-bit pointers[6] Available in Java 6 with -XX:+UseCompressedOops<br />Small language changes (grouped under a project named Coin):[7]<br /><br /><br /><br /><br />Strings in switch[8]<br />Automatic resource management in try-statement[9]<br />Improved type inference for generic instance creation[10]<br />Simplified varargs method declaration[11]<br />Binary integer literals[12]<br />Allowing underscores in numeric literals[13]<br />Catching multiple exception types and rethrowing exceptions with improved type checking[14]<br /><br /><br /><br /><br />Concurrency utilities under JSR 166[15]<br />New file I/O library to enhance platform independence and add support for metadata and symbolic links. The new packages are java.nio.file and java.nio.file.attribute[16][17]<br />Library-level support for Elliptic curve cryptography algorithms<br />An XRender pipeline for Java 2D, which improves handling of features specific to modern GPUs<br />New platform APIs for the graphics features originally planned for release in Java version 6u10<br />Enhanced library-level support for new network protocols, including SCTP and Sockets Direct Protocol<br />Upstream updates to XML and Unicode<br /><br />Lambda (Java's implementation of lambda functions), Jigsaw (Java's implementation of modules), and part of Coin were dropped from Java 7. Java 8 will be released with the remaining features in summer 2013.[18]<br />"",""In most people's opinions, Java technology delivers reasonably well on all these goals. The language is not, however, without drawbacks. Java tends to be more high-level than similar languages (such as C++), which means that the Java language lacks features such as hardware-specific data types, low-level pointers to arbitrary memory addresses, or programming methods like operator overloading. Although these features are frequently abused or misused by programmers, they are also powerful tools. However, Java technology includes Java Native Interface (JNI), a way to call native code from Java language code. With JNI, it is still possible to use some of these features.<br />Some programmers also complain about its lack of multiple inheritance, a powerful feature of several object-oriented languages, among others C++. The Java language separates inheritance of type and implementation, allowing inheritance of multiple type definitions through interfaces, but only single inheritance of type implementation via class hierarchies. This allows most of the benefits of multiple inheritance while avoiding many of its dangers. In addition, through the use of concrete classes, abstract classes, as well as interfaces, a Java language programmer has the option of choosing full, partial, or zero implementation for the object type he defines, thus ensuring maximum flexibility in application design.<br />There are some who believe that for certain projects, object orientation makes work harder instead of easier. This particular complaint is not unique to the Java language but applies to other object-oriented languages as well.<br /><br /><br /> History<br />Java Programming<br />Java Overview<br />The Java Platform<br />""]}"
"{""result"":[""abstract is a Java keyword. It can be applied to a class and methods. An abstract class cannot be directly instantiated. It must be placed before the variable type or the method return type. It is recommended to place it after the access modifier and after the static keyword. A non-abstract class is a concrete class. An abstract class cannot be final.<br />Only an abstract class can have abstract methods. An abstract method is only declared, not implemented:<br /><br /><br /><br />Code listing 1: AbstractClass.java<br /><br /><br />1 public abstract class AbstractClass {<br />2     // This method does not have a body; it is abstract.<br />3     public abstract void abstractMethod();<br />4  <br />5     // This method does have a body; it is implemented in the abstract class and gives a default behavior.<br />6     public void concreteMethod() {<br />7         System.out.println(\""Already coded.\"");<br />8     }<br />9 }<br /><br /><br /><br /><br />An abstract method cannot be final, static nor native. Either you instantiate a concrete sub-class, either you instantiate the abstract class by implementing its abstract methods alongside a new statement:<br /><br /><br /><br />Code section 1: Abstract class use.<br /><br /><br />1 AbstractClass myInstance = new AbstractClass() {<br />2     public void abstractMethod() {<br />3         System.out.println(\""Implementation.\"");<br />4     }<br />5 };<br /><br /><br /><br /><br />A private method cannot be abstract.<br />"",""Now that we know how variables should be named, let us look at the values of those variables. Simple values like numbers are called literals. This section shows you what literals are and how to use them. Consider the following code:<br /><br /><br /><br />Code section 3.48: Literals.<br /><br /><br />1 int age = 24;<br />2 long bankBalance = 20000005L;<br /><br /><br /><br /><br />By now, we've only seen how numbers work in assignment statements. Let's look at data types other than numbers. Characters are basically letters of the English alphabet. When writing a single character, we use single quotes to encapsulate them. Take a look at the code below:<br /><br /><br /><br />Code section 3.49: Character.<br /><br /><br />1 char c = 'a';<br /><br /><br /><br /><br />Why, you ask? Well, the explanation is simple. If written without quotes, the system would think it's a variable identifier. That's the very distinction you have to make when differentiating between variables and their literal values. Character data types are a bit unusual. First, they can only hold a single character. What if you had to store a complete name within them, say John, would you write something like:<br /><br /><br /><br />Code section 3.50: Character list.<br /><br /><br />1 char firstChar = 'J';<br />2 char secondChar = 'o';<br />3 char thirdChar = 'h';<br />4 char fourthChar = 'n';<br /><br /><br /><br /><br />Now, that's pathetic. Thankfully, there's a data type that handles large number of characters, it's called a String. A string can be initialized as follows:<br /><br /><br /><br />Code section 3.51: String.<br /><br /><br />1 String name = \""John\"";<br /><br /><br /><br /><br />Notice, the use of double quotation marks instead of single quotation marks. That's the only thing you need to worry about.<br /><br /><br /><br /> Boolean expressions<br />Java Programming<br />Variables<br />Primitive Types<br />"",""We start with basic transfer object:<br /><br /><br /><br />Code listing 10.1: DummyTo.java<br /><br /><br /> 1 package com.test;<br /> 2  <br /> 3 public class DummyTo {<br /> 4     private String name;<br /> 5     private String address;<br /> 6  <br /> 7     public String getName() {<br /> 8         return name;<br /> 9     }<br />10  <br />11     public void setName(String name) {<br />12         this.name = name;<br />13     }<br />14  <br />15     public String getAddress() {<br />16         return address;<br />17     }<br />18  <br />19     public void setAddress(String address) {<br />20         this.address = address;<br />21     }<br />22  <br />23     public DummyTo(String name, String address) {<br />24         this.name = name;<br />25         this.address = address;<br />26     }<br />27  <br />28     public DummyTo() {<br />29         this.name = new String();<br />30         this.address = new String();<br />31     }<br />32  <br />33     public String toString(String appendBefore) {<br />34         return appendBefore + \"" \"" + name + \"", \"" + address;<br />35     }<br />36 }<br /><br /><br /><br /><br />Following is the example for invoking method from the above mentioned to dynamically. Code is self explanatory.<br /><br /><br /><br /><br /><br /><br />Code listing 10.2: ReflectTest.java<br /><br /><br /> 1 package com.test;<br /> 2  <br /> 3 import java.lang.reflect.Constructor;<br /> 4 import java.lang.reflect.InvocationTargetException;<br /> 5 import java.lang.reflect.Method;<br /> 6  <br /> 7 public class ReflectTest {<br /> 8     public static void main(String[] args) {<br /> 9         try {<br />10             Class<?> dummyClass = Class.forName(\""com.test.DummyTo\"");<br />11  <br />12             // parameter types for methods<br />13             Class<?>[] partypes = new Class[]{String.class};<br />14  <br />15             // Create method object. methodname and parameter types<br />16             Method meth = dummyClass.getMethod(\""toString\"", partypes);<br />17  <br />18             // parameter types for constructor<br />19             Class<?>[] constrpartypes = new Class[]{String.class, String.class};<br />20  <br />21             //Create constructor object. parameter types<br />22             Constructor<?> constr = dummyClass.getConstructor(constrpartypes);<br />23  <br />24             // create instance<br />25             Object dummyto = constr.newInstance(new Object[]{\""Java Programmer\"", \""India\""});<br />26  <br />27             // Arguments to be passed into method<br />28             Object[] arglist = new Object[]{\""I am\""};<br />29  <br />30             // invoke method!!<br />31             String output = (String) meth.invoke(dummyto, arglist);<br />32             System.out.println(output);<br />33  <br />34         } catch (ClassNotFoundException e) {<br />35             e.printStackTrace();<br />36         } catch (SecurityException e) {<br />37             e.printStackTrace();<br />38         } catch (NoSuchMethodException e) {<br />39             e.printStackTrace();<br />40         } catch (IllegalArgumentException e) {<br />41             e.printStackTrace();<br />42         } catch (IllegalAccessException e) {<br />43             e.printStackTrace();<br />44         } catch (InvocationTargetException e) {<br />45             e.printStackTrace();<br />46         } catch (InstantiationException e) {<br />47             e.printStackTrace();<br />48         }<br />49     }<br />50 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Console for Code listing 10.2<br /><br />I am Java Programmer, India<br /><br /><br /><br /><br /><br /><br />Conclusion: Above examples demonstrate the invocation of method dynamically using reflection.<br /><br /><br /><br /><br /><br /><br /><br />To do:<br />Add some exercises like the ones in Variables<br /><br /><br /><br /><br /><br /><br /> Dynamic Class Loading<br />Java Programming/Reflection<br />Dynamic Invocation<br />Accessing Private Features with Reflection<br />"",""An interface is an abstraction of class with no implementation details. For example, java.lang.Comparable is a standard interface in Java. You cannot instantiate an interface. An interface is not a class but it is written the same way. The first difference is that you do not use the class keyword but the interface keyword to define it. Then, there are fields and methods you cannot define here:<br /><br />A field is always a constant: it is always public, static and final, even if you do not mention it.<br />A method must be public and abstract, but it is not required to write the public and abstract keywords.<br />Constructors are forbidden.<br /><br />An interface represents a contract:<br /><br /><br /><br />Code listing 4.14: SimpleInterface.java<br /><br /><br />1 public interface SimpleInterface {<br />2     public static final int CONSTANT1 = 1;<br />3     int method1(String parameter);<br />4 }<br /><br /><br /><br /><br />You can see that the method1() method is abstract (unimplemented). To use an interface, you have to define a class that implements it, using the implements keyword:<br /><br /><br /><br />Code listing 4.15: ClassWithInterface.java<br /><br /><br />1 public class ClassWithInterface implements SimpleInterface {<br />2     int method1(String parameter) {<br />3         return 0;<br />4     }<br />5 }<br /><br /><br /><br /><br />A class can implement several interface, separated by a comma. Java interfaces behave much like the concept of the Objective-C protocol. It is recommended to name an interface <verb>able, to mean the type of action this interface would enable on a class. However, it is not recommended to start the name of an interface by I as in C++. It is useless. Your IDE will help you instead.<br />"",""It may also be sometimes useful to create substrings, or strings using the order of letters from an existing string. This can be done in two methods.<br />The first method involves creating a substring out of the characters of a string from a given index to the end:<br /><br /><br /><br /><br /><br /><br />Code section 3.94: Truncating string.<br /><br /><br />1 String str = \""coffee\"";<br />2 System.out.println(str.substring(3));<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Output for Code section 3.94<br /><br />fee<br /><br /><br /><br /><br /><br /><br />The index of the first character in a string is 0.<br /><br /><br />c<br />o<br />f<br />f<br />e<br />e<br /><br /><br />0<br />1<br />2<br />3<br />4<br />5<br /><br /><br />By counting from there, it is apparent that the character in index 3 is the second \""f\"" in \""coffee\"". This is known as the beginIndex. All characters from the beginIndex until the end of the string will be copied into the new substring.<br />The second method involves a user-defined beginIndex and endIndex:<br /><br /><br /><br /><br /><br /><br />Code section 3.95: Extraction of string.<br /><br /><br />1 String str = \""supporting\"";<br />2 System.out.println(str.substring(3, 7));<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Output for Code section 3.95<br /><br />port<br /><br /><br /><br /><br /><br /><br />The string returned by substring() would be \""port\"".<br /><br /><br />s<br />u<br />p<br />p<br />o<br />r<br />t<br />i<br />n<br />g<br /><br /><br />0<br />1<br />2<br />3<br />4<br />5<br />6<br />7<br />8<br />9<br /><br /><br />Please note that the endIndex is not inclusive. This means that the last character will be of the index endIndex-1. Therefore, in this example, every character from index 3 to index 6, inclusive, was copied into the substring.<br /><br /><br /><br />It is easy to mistake the method substring() for subString() (which does not exist and would return with a syntax error on compilation). Substring is considered to be one word. This is why the method name does not seem to follow the common syntax of Java. Just remember that this style only applies to methods or other elements that are made up of more than one word.<br />"",""String literals consist of the double quote character (\"") (ASCII 34, hex 0x22), zero or more characters (including Unicode characters), followed by a terminating double quote character (\""), such as: \""Ceci est une string.\""<br />So a string literal follows the following grammar:<br /><br /><STRING :<br />        \""\\\""\""<br />        (    (~[\""\\\""\"",\""\\\\\"",\""\\n\"",\""\\r\""])<br />        |(\""\\\\\""<br />            ( [\""n\"",\""t\"",\""b\"",\""r\"",\""f\"",\""\\\\\"",\""'\"",\""\\\""\""]<br />            |[\""0\""-\""7\""]([\""0\""-\""7\""])?<br />            |[\""0\""-\""3\""][\""0\""-\""7\""][\""0\""-\""7\""]<br />            )<br />        )<br />        )*<br />        \""\\\""\""><br /><br />Within string and character literals, the backslash character can be used to escape special characters, such as unicode escape sequences, or the following special characters:<br /><br /><br />Name<br />Character<br />ASCII<br />hex<br /><br /><br />Backspace<br />\\b<br />8<br />0x08<br /><br /><br />TAB<br />\\t<br />9<br />0x09<br /><br /><br />NUL character<br />\\0<br />0<br />0x00<br /><br /><br />newline<br />\\n<br />10<br />0x0a<br /><br /><br />carriage control<br />\\r<br />13<br />0xd<br /><br /><br />double quote<br />\\\""<br />34<br />0x22<br /><br /><br />single quote<br />\\'<br />39<br />0x27<br /><br /><br />backslash<br />\\\\<br />92<br />0x5c<br /><br /><br />String literals may not contain unescaped newline or linefeed characters. However, the Java compiler will evaluate compile time expressions, so the following String expression results in a string with three lines of text:<br /><br /><br /><br />Code section 3.64: Multi-line string.<br /><br /><br />1 String text = \""This is a String literal\\n\""<br />2             + \""which spans not one and not two\\n\""<br />3             + \""but three lines of text.\\n\"";<br />"",""Output Streams direct streams of bytes outwards to the environment from our program or application. OutputStream is an abstract class which is the destination counterpart of InputStream. OutputStream has a write() method which can be used to write a byte to the stream. The method is overloaded, and can take an array as well. A close() method closes the stream when the application is finished with it, and it has a flush() method. The stream may wait until it has a certain amount before it writes it all at once for efficiency. If the stream object is buffering any data before writing it, the flush() method will force it to write all of this data. Like InputStream, this class cannot be instantiated, but has concrete subclasses that parallel those of InputStream, eg ByteArrayOutputStream, FileOutputStream, etc.<br />In the following example, we store the current time in an already existing file called log.txt located in the same folder than the class.<br /><br /><br /><br />Code listing 9.2: Example of output stream.<br /><br /><br /> 1 import java.io.File;<br /> 2 import java.io.FileOutputStream;<br /> 3 import java.util.Date;<br /> 4  <br /> 5 public class LogTime {<br /> 6     public static void main(String[] args) throws Exception {<br /> 7         // Generate data<br /> 8         String timeInString = new Date().toString();<br /> 9 <br />10         // Store data<br />11         File file = new File(\""log.txt\"");<br />12         FileOutputStream stream = new FileOutputStream(file);<br />13 <br />14         byte[] timeInBytes = timeInString.getBytes();<br />15 <br />16         stream.write(timeInBytes);<br />17         stream.flush();<br />18         stream.close();<br />19     }<br />20 }<br /><br /><br /><br /><br />This case is more simple as we can put all the data in the stream at the same time. The first part of the code generate a string containing the current time. Then we create a File object identifying the output file and an output stream for this file. We write the data in the stream, flush it and close it. That's all. No try/catch block has been defined for readability but the thrown exceptions should be caught.<br /><br /><br /><br />In order to read a text file several times from the beginning, a FileChannel variable should be introduced, only to reposition the reader.<br /><br /><br />Now let's execute it:<br /><br /><br /><br />LogTime execution<br /><br />$ java LogTime<br /><br /><br /><br />We should obtain this content:<br /><br /><br /><br />Code listing 9.4: log.txt<br />Wed Feb 17 7:04:44 CEUTC 2016<br /><br /><br /><br /><br /><br /><br />If it shows a FileNotFoundException or an IOException, the file should not have been created or it is not placed in the right folder.<br /><br /><br />There is also Writer which is a character counterpart of OutputStream, and a destination counterpart to Reader, this is also an abstract superclass. Particular implementations parallel those of Reader, eg FileWriter, StringWriter, and OutputStreamWriter, for converting a regular OutputStream into a reader so that it can take character data.<br />"",""Unicode characters can also be expressed through Unicode Escape Sequences. Unicode escape sequence may appear anywhere in a Java source file (including inside identifiers, comments, and string literals).<br />Unicode escape sequences consist of<br /><br />a backslash '\\' (ASCII character 92, hex 0x5c),<br />a 'u' (ASCII 117, hex 0x75)<br />optionally one or more additional 'u' characters, and<br />four hexadecimal digits (the characters '0' through '9' or 'a' through 'f' or 'A' through 'F').<br /><br />Such sequences represent the UTF-16 encoding of a Unicode character. For example, 'a' is equivalent to '\\u0061'. This escape method does not support characters beyond U+FFFF or you have to make use of surrogate pairs.[1]<br />Any and all characters in a program may be expressed in Unicode escape characters, but such programs are not very readable, except by the Java compiler - in addition, they are not very compact.<br />One can find a full list of the characters here.<br />π may also be represented in Java as the Unicode escape sequence \\u03C0. Thus, the following is a valid, but not very readable, declaration and assignment:<br /><br /><br /><br />Code section 3.102: Unicode escape sequences for Pi.<br /><br /><br />1 double \\u03C0 = Math.PI;<br /><br /><br /><br /><br />The following demonstrates the use of Unicode escape sequences in other Java syntax:<br /><br /><br /><br />Code section 3.103: Unicode escape sequences in a string literal.<br /><br /><br />1 // Declare Strings pi and quote which contain \\u03C0 and \\u0027 respectively:<br />2 String pi = \""\\u03C0\"";<br />3 String quote = \""\\u0027\"";<br /><br /><br /><br /><br />Note that a Unicode escape sequence functions just like any other character in the source code. E.g., \\u0022 (double quote, \"") needs to be quoted in a string just like \"".<br /><br /><br /><br />Code section 3.104: Double quote.<br /><br /><br />1 // Declare Strings doubleQuote1 and doubleQuote2 which both contain \"" (double quote):<br />2 String doubleQuote1 = \""\\\""\"";<br />3 String doubleQuote2 = \""\\\\u0022\""; // \""\\u0022\"" doesn't work since \""\""\"" doesn't work.<br />"",""A generic type can be defined for just a method:<br /><br /><br /><br />Code section 4.37: Generic method.<br /><br /><br />1 public <D> D assign(Collection<D> generic, D obj) {<br />2   generic.add(obj);<br />3   return obj;<br />4 }<br /><br /><br /><br /><br />Here a new identifier (D) has been chosen at the beginning of the method declaration. The type is specific to a method call and different types can be used for the same object instance:<br /><br /><br /><br />Code section 4.38: Generic method call.<br /><br /><br />1 Collection<Integer> numbers = new ArrayList<Integer>();<br />2 Integer number = assign(numbers, new Integer(1));<br />3 Collection<String> texts = new ArrayList<String>();<br />4 String text = assign(texts, \""Store it.\"");<br /><br /><br /><br /><br />The actual type will be defined by the type of the method parameter. Hence, the generic type can't be defined only for the return value as it wouldn't be resolved. See the Class<T> section for a solution.<br /><br />Test your knowledge<br /><br />Question 4.8: Consider the following class.<br /><br /><br /><br />Question 4.8: Question8.java<br /><br /><br /> 1 public class Question8<T> {<br /> 2   public T item;<br /> 3  <br /> 4   public T getItem() {<br /> 5     return item;<br /> 6   }<br /> 7  <br /> 8   public void setItem(T newItem) {<br /> 9     item = newItem;<br />10   }<br />11 <br />12   public static void main(String[] args) {<br />13     Question8<String> aQuestion = new Question8<String>();<br />14     aQuestion.setItem(\""Open your mind.\"");<br />15     aQuestion.display(aQuestion.getItem());<br />16   }<br />17 <br />18   public void display(String parameter) {<br />19     System.out.println(\""Here is the text: \"" + parameter);<br />20   }<br />21 <br />22   public void display(Integer parameter) {<br />23     System.out.println(\""Here is the number: \"" + parameter);<br />24   }<br />25 <br />26   public void display(Object parameter) {<br />27     System.out.println(\""Here is the object: \"" + parameter);<br />28   }<br />29 }<br /><br /><br /><br /><br />What will be displayed on the console?<br /><br />Answer<br /><br /><br /><br /><br />Console for Answer 4.8<br /><br />Here is the text: Open your mind.<br /><br /><br /><br />aQuestion.getItem() is typed as a string.<br />"",""A constructor is a special method in a class which is used to construct an instance of the class. The constructor can perform initialization for the object, beyond that which the Java VM does automatically. For example, Java will automatically initialize the fields point0 and point1 to null.<br /><br /><br /><br />Code section 2.4: The constructor for the class<br /><br /><br />1 public Distance(int x0, int y0, int x1, int y1) {<br />2    point0 = new java.awt.Point(x0, y0);<br />3    point1 = new java.awt.Point(x1, y1);<br />4 }<br /><br /><br /><br /><br />The constructor above consists of five parts:<br /><br />The optional access modifier(s).<br />In this case, the constructor is declared public<br />The constructor name, which must match the class name exactly: Distance in this case.<br />The constructor parameters.<br />The parameter list is required. Even if a constructor does not have any parameters, you must specify the empty list (). The parameter list declares the type and name of each of the method's parameters.<br />An optional throws clause which declares the exceptions that the constructor may throw. This constructor does not declare any exceptions.<br />The constructor body, which is a Java block (enclosed in {}). This constructor's body contains two statements.<br /><br />This constructor accepts four parameters, named x0, y0, x1 and y1. Each parameter requires a parameter type declaration, which in this example is int for all four parameters. The parameters in the parameter list are separated by commas.<br />The two assignments in this constructor use Java's new operator to allocate two java.awt.Point objects. The first allocates an object representing the first point, (x0, y0), and assigns it to the point0 instance variable (replacing the null value that the instance variable was initialized to). The second statement allocates a second java.awt.Point instance with (x1, y1) and assigns it to the point1 instance variable.<br />This is the constructor for the Distance class. Distance implicitly extends from java.lang.Object. Java inserts a call to the super constructor as the first executable statement of the constructor if there is not one explicitly coded. The above constructor body is equivalent to the following body with the explicit super constructor call:<br /><br /><br /><br />Code section 2.5: Super constructor.<br /><br /><br />1 {<br />2    super();<br />3    point0 = new java.awt.Point(x0, y0);<br />4    point1 = new java.awt.Point(x1, y1);<br />5 }<br /><br /><br /><br /><br />While it is true that this class could be implemented in other ways, such as simply storing the coordinates of the two points and computing the distance as , this class instead uses the existing java.awt.Point class. This choice matches the abstract definition of this class: to print the distance between two points on the plane. We take advantage of existing behavior already implemented in the Java platform rather than implementing it again. We will see later how to make the program more flexible without adding much complexity, because we choose to use object abstractions here. However, the key point is that this class uses information hiding. That is, how the class stores its state or how it computes the distance is hidden. We can change this implementation without altering how clients use and invoke the class.<br />""]}"
"{""result"":[""Cloning is not automatically available to classes. There is some help though, as all Java objects inherit the protected Object clone() method. This base method would allocate the memory and do the bit by bit copying of the object's states.<br />You may ask why we need this clone method. Couldn't I create a constructor and just passing in the same object, and do the copying variable by variable? Let's see:<br /><br /><br /><br />Code listing 4.14: MyObject.java<br /><br /><br />1 public class MyObject {<br />2    private int memberVar;<br />3 ...<br />4    MyObject(MyObject obj) {<br />5       this.memberVar = obj.memberVar;<br />6     ...<br />7    }<br />8 ...<br />9 }<br /><br /><br /><br /><br />You might think that accessing the private memberVar variable of obj would fail but as this is in the same class this code is legal. The clone() method copies the whole object's memory in one operation. This is much faster than using the new keyword. Object creation with the new keyword is expensive, so if you need to create lots of objects with the same type, performance will be better if you create one object and clone new ones from it. See below a factory method that will return a new object using cloning.<br /><br /><br /><br />Code section 4.31: Object cloning.<br /><br /><br /> 1 HashTable cacheTemplate = new HashTable();<br /> 2 ...<br /> 3 /** Clone Customer object for performance reason */<br /> 4 public Customer createCustomerObject() {<br /> 5    // See if a template object exists in our cache<br /> 6    Customer template = cacheTemplate.get(\""Customer\"");<br /> 7    if (template == null) {<br /> 8       // Create template<br /> 9       template = new Customer();<br />10       cacheTemplate.put(\""Customer\"", template);<br />11    }<br />12   return template.clone();<br />13 }<br /><br /><br /><br /><br />Now, let's see how to make the Customer object cloneable.<br /><br />First the Customer class needs to implement the Cloneable Interface.<br />Override and make the clone() method public, as that is protected in the Object class.<br />Call the super.clone()method at the beginning of your clone method.<br />Override the clone() method in all the subclasses of Customer.<br /><br /><br /><br /><br />Code listing 4.15: Customer.java<br /><br /><br />1 public class Customer implements Cloneable {<br />2  ...<br />3     public Object clone() throws CloneNotSupportedException {<br />4        Object obj = super.clone();<br />5 <br />6        return obj;<br />7     }<br />8 }<br /><br /><br /><br /><br />In the code listing 4.15 we used cloning for speed up object creation. Another use of cloning could be to take a snapshot of an object that can change in time. Let's say we want to store Customer objects in a collection, but we want to disassociate them from the 'live' objects. So before adding the object, we clone them, so if the original object changes from that point forward, the added object won't. Also let's say that the Customer object has a reference to an Activity object that contains the customer activities. Now we are facing a problem, it is not enough to clone the Customer object, we also need to clone the referenced objects. The solution:<br /><br />Make the Activity class also cloneable<br />Make sure that if the Activity class has other 'changeable' object references, those has to be cloned as well, as seen below<br />Change the Customer class clone() method as follows:<br /><br /><br /><br /><br />Code listing 4.16: Customer.java<br /><br /><br /> 1 public class Customer implements Cloneable {<br /> 2   Activity activity;<br /> 3   ...<br /> 4     public Customer clone() throws CloneNotSupportedException {<br /> 5       Customer clonedCustomer = (Customer) super.clone();<br /> 6 <br /> 7       // Clone the object referenced objects<br /> 8       if (activity != null) {<br /> 9          clonedCustomer.setActivity((Activity) activity.clone());<br />10       }<br />11       return clonedCustomer;<br />12    }<br />13 }<br /><br /><br /><br /><br />Note that only mutable objects needs to be cloned. References to unchangeable objects such as String be used in the cloned object without worry.<br />"",""The java.lang.Object.clone() method returns a new object that is a copy of the current object. Classes must implement the marker interface java.lang.Cloneable to indicate that they can be cloned.<br />"",""The BigInteger class represents integers of almost any size. As with other objects, they need to be constructed. Unlike regular numbers, the BigInteger represents an immutable object - methods in use by the BigInteger class will return a new copy of a BigInteger.<br />To instantiate a BigInteger, you can create it from either byte array, or from a string. For example:<br /><br /><br /><br />Code section 3.23: 1 quintillion, or 10^18. Too large to fit in a long.<br /><br /><br />1 BigInteger i = new BigInteger(\""1000000000000000000\"");<br /><br /><br /><br /><br />BigInteger cannot use the normal Java operators. They use the methods provided by the class.<br /><br /><br /><br />Code section 3.24: Multiplications and an addition.<br /><br /><br />1 BigInteger a = new BigInteger(\""3\"");<br />2 BigInteger b = new BigInteger(\""4\"");<br />3 <br />4 // c = a^2 + b^2<br />5 BigInteger c = a.multiply(a).add(b.multiply(b));<br /><br /><br /><br /><br />It is possible to convert to a long, but the long may not be large enough.<br /><br /><br /><br />Code section 3.25: Conversion.<br /><br /><br />1 BigInteger aBigInteger = new BigInteger(\""3\"");<br />2 long aLong = aBigInteger.longValue();<br />"",""Objects put into a collection are upcasted to Object class. It means that you need to cast the object reference back when you get an element out from the collection. It also means that you need to know the type of the object when you take it out. If a collection contains different types of objects, we will have difficulty finding out the type of the objects obtained from a collection at run time. Let's use a collection with any objects in it:<br /><br /><br /><br />Code section 5.1: Collection feeding.<br /><br /><br />1 Collection ageList = new ArrayList();<br />2 ageList.add(new Integer(46));<br />3 ageList.add(\""50\"");<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Code section 5.2: Collection reading.<br /><br /><br />1 Integer sum = new Integer(0);<br />2 for (Object age : ageList) {<br />3     sum = sum.add((Integer) age);<br />4 }<br />5 <br />6 if (!ageList.isEmpty()) {<br />7     System.out.println(\""The average age is \"" + sum / ageList.size());<br />8 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Console for Code section 5.2<br /><br />ClassCastException.<br /><br /><br /><br /><br /><br /><br />This error could have been fixed earlier, at compile time, using generic types.<br />The Generics has been added since JDK version 1.5. It is an enhancement to the type system of the Java language. All collection implementations since 1.5 now have one parameterized type <E> added. The E refers to an Element type. When a collection is created, the actual Element type will replace the E. In the collection, the objects are now upcasted to E class.<br /><br /><br /><br />Code section 5.3: Collection with generics.<br /><br /><br />1 Collection<Integer> ageList = new ArrayList<Integer>();<br />2 ageList.add(new Integer(46));     // Integer can be added<br />3 ageList.add(\""50\"");                // Compilation error, ageList can have only Integers inside<br /><br /><br /><br /><br /><br />ageList is a collection that can contain only Integer objects as elements. No casting is required when we take out an element.<br /><br /><br /><br />Code section 5.4: Item reading.<br /><br /><br />1 Integer age = ageList.get(0);<br /><br /><br /><br /><br />Generics is not mandatory but it is often used with the collection classes.<br />"",""In order to get from class to object, we \""build\"" our object by instantiation. Instantiation simply means to create an instance of a class. Instance and object are very similar terms and are sometimes interchangeable, but remember that an instance refers to a specific object, which was created from a class.<br />This instantiation is brought about by one of the class's methods, called a constructor. As its name implies, a constructor builds the object based on the blueprint. Behind the scenes, this means that computer memory is being allocated for the instance, and values are being assigned to the data members.<br />In general there are four constructor types: default, non-default, copy, and cloning.<br />A default constructor will build the most basic instance. Generally, this means assigning all the fields values like null, zero, or an empty string. Nothing would stop you, however, from your default sports car color from being red, but this is generally bad programming style. Another programmer would be confused if your basic car came out red instead of say, colorless.<br /><br /><br /><br />Code section 3.79: A default constructor.<br /><br /><br />1 SportsCar car = new SportsCar();<br /><br /><br /><br /><br />A non-default constructor is designed to create an object instance with prescribed values for most, if not all, of the object's fields. The car is red, goes from 0-60 in 12 seconds, tops out at 190mph, etc.<br /><br /><br /><br />Code section 3.80: A non-default constructor.<br /><br /><br />1 SportsCar car = new SportsCar(\""red\"", 12, 190);<br /><br /><br /><br /><br />A copy constructor is not included in the Java language, however one can easily create a constructor that do the same as a copy constructor. It's important to understand what it is. As the name implies, a copy constructor creates a new instance to be a duplicate of an already existing one. In Java, this can be also accomplished by creating the instance with the default constructor, and then using the assignment operator to equivocate them. This is not possible in all languages though, so just keep the terminology under your belt.<br />Java has the concepts of cloning object, and the end results are similar to copy constructor. Cloning an object is faster than creation with the new keyword, because all the object memory is copied at once to destination cloned object. This is possible by implementing the Cloneable interface, which allows the method Object.clone() to perform a field-by-field copy.<br /><br /><br /><br />Code section 3.81: Cloning object.<br /><br /><br />1 SportsCar car = oldCar.clone();<br />"",""The object references are passed by value. It means that:<br /><br />There is no more link between the reference inside the method and the source reference,<br />The source object itself and the object itself inside the method are still the same.<br /><br />You must understand the difference between the reference of an object and the object itself. A object reference is the link between a variable name and an instance of object:<br /><br /><br />Object object ⇔ new Object()<br /><br /><br />An object reference is a pointer, an address to the object instance.<br />The object itself is the value of its attributes inside the object instance:<br /><br /><br />object.firstName<br />⇒<br />\""James\""<br /><br /><br />object.lastName<br />⇒<br />\""Gosling\""<br /><br /><br />object.birthDay<br />⇒<br />\""May 19\""<br /><br /><br />Take a look at the example above:<br /><br /><br /><br />Code section 3.71: A method modifying an object.<br /><br /><br />1 private void modifyObject(FirstClass anObject) {<br />2   anObject.setName(\""Susan\"");<br />3 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Code section 3.72: Parameter by reference.<br /><br /><br />1 FirstClass object = new FirstClass();<br />2 object.setName(\""Christin\"");<br />3 <br />4 modifyObject(object);<br />5 <br />6 System.out.println(object.getName());<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Output for Code section 3.72<br /><br />Susan<br /><br /><br /><br /><br /><br /><br />The name has changed because the method has changed the object itself and not the reference. Now take a look at the other example:<br /><br /><br /><br />Code section 3.73: A method modifying an object reference.<br /><br /><br />1 private void modifyObject(FirstClass anObject) {<br />2   anObject = new FirstClass();<br />3   anObject.setName(\""Susan\"");<br />4 }<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Code section 3.74: Parameter by reference.<br /><br /><br />1 FirstClass object = new FirstClass();<br />2 object.setName(\""Christin\"");<br />3 <br />4 modifyObject(object);<br />5 <br />6 System.out.println(object.getName());<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Output for Code section 3.74<br /><br />Christin<br /><br /><br /><br /><br /><br /><br />The name has not changed because the method has changed the reference and not the object itself. The behavior is the same as if the method was in-lined and the parameters were assigned to new variable names:<br /><br /><br /><br /><br /><br /><br />Code section 3.75: In-lined method.<br /><br /><br /> 1 FirstClass object = new FirstClass();<br /> 2 object.setName(\""Christin\"");<br /> 3 <br /> 4 // Start of the method<br /> 5 FirstClass anObject = object;<br /> 6 anObject = new FirstClass();<br /> 7 anObject.setName(\""Susan\"");<br /> 8 // End of the method<br /> 9 <br />10 System.out.println(object.getName());<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />Output for Code section 3.75<br /><br />Christin<br />"",""Static variables can be used as data sharing amongst objects of the same class. For example to implement a counter that stores the number of objects created at a given time can be defined as so:<br /><br /><br /><br /><br />Code listing 1: CountedObject.java<br /><br /><br /> 1 public CountedObject {<br /> 2    private static int counter;<br /> 3    ...<br /> 4    public AClass() {<br /> 5       ...<br /> 6       counter += 1;<br /> 7    }<br /> 8    ...<br /> 9    public int getNumberOfObjectsCreated() {<br />10       return counter;<br />11    }<br />12 }<br /><br /><br /><br /><br />The counter variable is incremented each time an object is created.<br />Public static variable should not be used, as these become global variables that can be accessed from everywhere in the program. Global constants can be used, however. See below:<br /><br /><br /><br />Code section 3: Constant definition.<br /><br /><br />1 public static final String CONSTANT_VAR = \""Const\"";<br /><br /><br /><br /><br /><br />Static methods can be used for utility functions or for functions that do not belong to any particular object. For example:<br /><br /><br /><br /><br />Code listing 2: ArithmeticToolbox.java<br /><br /><br />1 public ArithmeticToolbox {<br />2    ...<br />3    public static int addTwoNumbers(int firstNumber, int secondNumber) {<br />4         return firstNumber + secondNumber;<br />5    }<br />6 }<br /><br /><br /><br /><br /><br />See also Static methods<br />"",""After J2EE, Sun had a vision about the next step of network computing: in a network environment, there would be many independent services and consumers. That is JavaSpaces. JavaSpaces would allow these services/consumers to interact dynamically with each other in a robust way. It can be viewed as an object repository that provides a distributed persistent object exchange mechanism (persistent can be in memory or disk) for Java objects. It can be used to store the system state and implement distributed algorithms. In a JavaSpace, all communication partners (peers) communicate by sharing state. It is an implementation of the Tuple spaces idea.<br />JavaSpaces is used when someone wants to achieve scalability and availability and at the same time reducing the complexity of the overall system.<br />Processes perform simple operations to write new objects into a JavaSpace, take objects from a JavaSpace, or read (make a copy of) objects from the JavaSpace.<br />In conventional applications, objects are assembled from the database before presenting to the end user. In JavaSpace applications, we keep the ready made \""end user\"" objects and store them in the JavaSpace. In JavaSpace applications the services are decoupled from each other; they communicate through objects that they write and read/take from the JavaSpace. Services search for objects that they want to take or read from the Space by using template object.<br />"",""In Java and J2EE programming, you can call a method on an object only if it is casted to a class or an interface that declares it. The structured definition of bean properties is very useful for comparing a single common property across several objects that are not and should not be related by inheritance.<br />For example, a program may contain both a bean representing a company's employees, and another containing a list of buildings that a company occupies. A programmer writing a function called listAssetNames() wants to write a simple way of getting the field \""name\"" from several beans that can get the field from both Employee and Building beans, and that can be easily adapted to get the same field from other types of beans that may not be written yet.<br />While this could be done by rewriting both Employee and Building so that they each inherit from one class named NamedObject, or by creating a NamedObject interface, both methods have their own problems. Using inheritance is limiting, as each child class can only inherit from one parent class, which limits the number of different classes that can share properties, as well as the number of common properties that can be shared. Furthermore, using inheritance to express relationships other than a simple \""is-a\"" relationship can be confusing, as can looking through dozens of class definitions to find where a single \""dumb\"" getter function is implemented. Creating an interface fixes the problems caused by the multiple inheritance rule, as a class can use any number of interfaces, but it still requires every shared property to be explicitly spelled out.<br />The simplest, most elegant way to deal with this type of relationship is to read the bean properties using introspection. The jakarta BeanUtils package is a common way of handling objects that need to be related in this way, as it takes advantage of the regularity of JavaBean naming conventions.<br /><br /><br /><br />Code listing 9.13: Get property from a JavaBean<br /><br /><br /> 1 public static Object getProperty(Object o, String propertyName) {<br /> 2    if (o == null ||<br /> 3        propertyName == null ||<br /> 4        propertyName.length() < 1) {<br /> 5       return null;<br /> 6    }<br /> 7    // Based on the property name build the getter method name<br /> 8    String methodName = \""get\"" +<br /> 9                       propertyName.substring(0,1).toUpperCase() +<br />10                       propertyName.substring(1);<br />11    Object property = null;<br />12    try {<br />13       java.lang.Class c = o.getClass();<br />14       java.lang.reflect.Method m = c.getMethod(methodName, null);<br />15       property = m.invoke(o, null);<br />16    } catch (NoSuchMethodException e) {<br />17      // Handle exception<br />18    }  catch (SecurityException e) {<br />19      // No permission; Handle exception<br />20    }<br />21 return property;<br />22 }<br /><br /><br /><br /><br />or<br /><br /><br /><br />Code listing 9.14: Use Apache Commons BeanUtils<br /><br /><br /> 1 import org.apache.commons.beanutils.PropertyUtils;<br /> 2 <br /> 3 try {<br /> 4   Object myValue = PropertyUtils.getSimpleProperty(o, propertyName);<br /> 5 } catch (IllegalAccessException e) {<br /> 6   // Handle exception<br /> 7 } catch (InvocationTargetException e) {<br /> 8   // Handle exception<br /> 9 } catch (NoSuchMethodException e) {<br />10   // Handle exception<br />11 }<br />"",""Before a Java object can be created the class byte code must be loaded from the file system (with .class extension) to memory. This process of locating the byte code for a given class name and converting that code into a Java class instance is known as class loading. There is one class created for each type of Java class.<br />All objects in Java programs are created on heap memory. An object is created based on its class. You can consider a class as a blueprint, template, or a description how to create an object. When an object is created, memory is allocated to hold the object properties. An object reference pointing to that memory location is also created. To use the object in the future, that object reference has to be stored as a local variable or as an object member variable.<br />The Java Virtual Machine (JVM) keeps track of the usage of object references. If there are no more reference to the object, the object can not be used any more and becomes garbage. After a while the heap memory will be full of unused objects. The JVM collects those garbage objects and frees the memory they allocated, so the memory can be reused again when a new object is created. See below a simple example:<br /><br /><br /><br />Code section 4.30: Object creation.<br /><br /><br />1 {<br />2   // Create an object<br />3   MyObject obj = new MyObject();<br />4 <br />5   // Use the object<br />6   obj.printMyValues();<br />7 }<br /><br /><br /><br /><br />The obj variable contains the object reference pointing to an object created from the MyObject class. The obj object reference is in scope inside the { }. After the } the object becomes garbage. Object references can be passed in to methods and can be returned from methods.<br />""]}"
"{""result"":[""A class with this package declaration<br /><br /><br /><br />Code section 2.2: Package declaration with sub-packages<br /><br /><br />package org.wikibooks.en;<br /><br /><br /><br /><br />has to be in a directory named en which has to be a sub-directory of wikibooks which in turn has to be a sub-directory of org resulting in org/wikibooks/en on Linux or org\\wikibooks\\en on Windows.<br />Java programs often contain non-code files such as images and properties files. These are referred to generally as resources and stored in directories local to the classes in which they're used. For example, if the class com.example.ExampleApp uses the icon.png file, this file could be stored as /com/example/resources/icon.png. These resources present a problem when a program is complied, because javac does not copy them to wherever the .class files are being complied to (see above); it is up to the programmer to move the resource files and directories.<br />"",""The requirements for an object to be a bean is to define a public parameterless constructor, so that beans can be instantiated by builder tools in an uncomplicated way (In the Point bean, the parameterless constructor is given implicitly). Secondly, one of the interfaces java.io.Serializable or java.io.Externalizable need to be implemented. The interfaces do not prescribe the implementation of any methods, but are an approval, that the bean may be saved in persistent storage as in a file or database. In doing so, the bean can be restored after an application was shut down or transferred across networks. The ability to store state of a component in persistent storage is called persistence. Java offers a standard serialization mechanism, which makes it very easy to serialize objects. Alternatively, a component can be stored in a customized manner (e.g. in xml format) by implementing the Externalizable interface.<br />"",""In order to get from class to object, we \""build\"" our object by instantiation. Instantiation simply means to create an instance of a class. Instance and object are very similar terms and are sometimes interchangeable, but remember that an instance refers to a specific object, which was created from a class.<br />This instantiation is brought about by one of the class's methods, called a constructor. As its name implies, a constructor builds the object based on the blueprint. Behind the scenes, this means that computer memory is being allocated for the instance, and values are being assigned to the data members.<br />In general there are four constructor types: default, non-default, copy, and cloning.<br />A default constructor will build the most basic instance. Generally, this means assigning all the fields values like null, zero, or an empty string. Nothing would stop you, however, from your default sports car color from being red, but this is generally bad programming style. Another programmer would be confused if your basic car came out red instead of say, colorless.<br /><br /><br /><br />Code section 3.79: A default constructor.<br /><br /><br />1 SportsCar car = new SportsCar();<br /><br /><br /><br /><br />A non-default constructor is designed to create an object instance with prescribed values for most, if not all, of the object's fields. The car is red, goes from 0-60 in 12 seconds, tops out at 190mph, etc.<br /><br /><br /><br />Code section 3.80: A non-default constructor.<br /><br /><br />1 SportsCar car = new SportsCar(\""red\"", 12, 190);<br /><br /><br /><br /><br />A copy constructor is not included in the Java language, however one can easily create a constructor that do the same as a copy constructor. It's important to understand what it is. As the name implies, a copy constructor creates a new instance to be a duplicate of an already existing one. In Java, this can be also accomplished by creating the instance with the default constructor, and then using the assignment operator to equivocate them. This is not possible in all languages though, so just keep the terminology under your belt.<br />Java has the concepts of cloning object, and the end results are similar to copy constructor. Cloning an object is faster than creation with the new keyword, because all the object memory is copied at once to destination cloned object. This is possible by implementing the Cloneable interface, which allows the method Object.clone() to perform a field-by-field copy.<br /><br /><br /><br />Code section 3.81: Cloning object.<br /><br /><br />1 SportsCar car = oldCar.clone();<br />"",""A constructor is called to initialize an object immediately after the object has been allocated:<br /><br /><br /><br />Code listing 4.3: Cheese.java<br /><br /><br />1 public class Cheese {<br />2   // This is a constructor<br />3   public Cheese() {<br />4     System.out.println(\""Construct an instance\"");<br />5   }<br />6 }<br /><br /><br /><br /><br />Typically, a constructor is invoked using the new keyword:<br /><br /><br /><br />Code section 4.1: A constructor call.<br /><br /><br />1 Cheese cheese = new Cheese();<br /><br /><br /><br /><br />The constructor syntax is close to the method syntax. However, the constructor has the same name as the name of the class (with the same case) and the constructor has no return type. The second point is the most important difference as a method can also have the same name as the class, which is not recommended:<br /><br /><br /><br />Code listing 4.4: Cheese.java<br /><br /><br />1 public class Cheese {<br />2   // This is a method with the same name as the class<br />3   public void Cheese() {<br />4     System.out.println(\""A method execution.\"");<br />5   }<br />6 }<br /><br /><br /><br /><br />The returned object is always a valid, meaningful object, as opposed to relying on a separate initialization method. A constructor cannot be abstract, final, native, static, strictfp nor synchronized. However, a constructor, like methods, can be overloaded and take parameters.<br /><br /><br /><br />Code listing 4.5: Cheese.java<br /><br /><br /> 1 public class Cheese {<br /> 2      // This is a constructor<br /> 3      public Cheese() {<br /> 4           doStuff();<br /> 5      }<br /> 6 <br /> 7      // This is another constructor<br /> 8      public Cheese(int weight) {<br /> 9           doStuff();<br />10      }<br />11 <br />12      // This is yet another constructor<br />13      public Cheese(String type, int weight) {<br />14           doStuff();<br />15      }<br />16 }<br /><br /><br /><br /><br />By convention, a constructor that accepts an object of its own type as a parameter and copies the data members is called a copy constructor. One interesting feature of constructors is that if and only if you do not specify a constructor in your class, the compiler will create one for you. This default constructor, if written out would look like:<br /><br /><br /><br />Code listing 4.6: Cheese.java<br /><br /><br />1 public class Cheese {<br />2      public Cheese() {<br />3            super();<br />4      }<br />5 }<br /><br /><br /><br /><br />The super() command calls the constructor of the superclass. If there is no explicit call to super(...) or this(...), then the default superclass constructor super(); is called before the body of the constructor is executed. That said, there are instances where you need to add in the call manually. For example, if you write even one constructor, no matter what parameters it takes, the compiler will not add a default constructor. The code listing 4.8 results in a runtime error:<br /><br /><br /><br />Code listing 4.7: Cheese.java<br /><br /><br />1 public class Cheese {<br />2      public Cheese(int weight, String type) {<br />3           doStuff();<br />4      }<br />5 }<br /><br /><br /><br /><br /><br /><br /><br />Code listing 4.8: Mouse.java<br /><br /><br />1 public class Mouse {<br />2      public void eatCheese() {<br />3              Cheese c = new Cheese(); // Oops, compile time error!<br />4      }<br />5 }<br /><br /><br /><br /><br />This is something to keep in mind when extending existing classes. Either make a default constructor, or make sure every class that inherits your class uses the correct constructor.<br />"",""Cloning is not automatically available to classes. There is some help though, as all Java objects inherit the protected Object clone() method. This base method would allocate the memory and do the bit by bit copying of the object's states.<br />You may ask why we need this clone method. Couldn't I create a constructor and just passing in the same object, and do the copying variable by variable? Let's see:<br /><br /><br /><br />Code listing 4.14: MyObject.java<br /><br /><br />1 public class MyObject {<br />2    private int memberVar;<br />3 ...<br />4    MyObject(MyObject obj) {<br />5       this.memberVar = obj.memberVar;<br />6     ...<br />7    }<br />8 ...<br />9 }<br /><br /><br /><br /><br />You might think that accessing the private memberVar variable of obj would fail but as this is in the same class this code is legal. The clone() method copies the whole object's memory in one operation. This is much faster than using the new keyword. Object creation with the new keyword is expensive, so if you need to create lots of objects with the same type, performance will be better if you create one object and clone new ones from it. See below a factory method that will return a new object using cloning.<br /><br /><br /><br />Code section 4.31: Object cloning.<br /><br /><br /> 1 HashTable cacheTemplate = new HashTable();<br /> 2 ...<br /> 3 /** Clone Customer object for performance reason */<br /> 4 public Customer createCustomerObject() {<br /> 5    // See if a template object exists in our cache<br /> 6    Customer template = cacheTemplate.get(\""Customer\"");<br /> 7    if (template == null) {<br /> 8       // Create template<br /> 9       template = new Customer();<br />10       cacheTemplate.put(\""Customer\"", template);<br />11    }<br />12   return template.clone();<br />13 }<br /><br /><br /><br /><br />Now, let's see how to make the Customer object cloneable.<br /><br />First the Customer class needs to implement the Cloneable Interface.<br />Override and make the clone() method public, as that is protected in the Object class.<br />Call the super.clone()method at the beginning of your clone method.<br />Override the clone() method in all the subclasses of Customer.<br /><br /><br /><br /><br />Code listing 4.15: Customer.java<br /><br /><br />1 public class Customer implements Cloneable {<br />2  ...<br />3     public Object clone() throws CloneNotSupportedException {<br />4        Object obj = super.clone();<br />5 <br />6        return obj;<br />7     }<br />8 }<br /><br /><br /><br /><br />In the code listing 4.15 we used cloning for speed up object creation. Another use of cloning could be to take a snapshot of an object that can change in time. Let's say we want to store Customer objects in a collection, but we want to disassociate them from the 'live' objects. So before adding the object, we clone them, so if the original object changes from that point forward, the added object won't. Also let's say that the Customer object has a reference to an Activity object that contains the customer activities. Now we are facing a problem, it is not enough to clone the Customer object, we also need to clone the referenced objects. The solution:<br /><br />Make the Activity class also cloneable<br />Make sure that if the Activity class has other 'changeable' object references, those has to be cloned as well, as seen below<br />Change the Customer class clone() method as follows:<br /><br /><br /><br /><br />Code listing 4.16: Customer.java<br /><br /><br /> 1 public class Customer implements Cloneable {<br /> 2   Activity activity;<br /> 3   ...<br /> 4     public Customer clone() throws CloneNotSupportedException {<br /> 5       Customer clonedCustomer = (Customer) super.clone();<br /> 6 <br /> 7       // Clone the object referenced objects<br /> 8       if (activity != null) {<br /> 9          clonedCustomer.setActivity((Activity) activity.clone());<br />10       }<br />11       return clonedCustomer;<br />12    }<br />13 }<br /><br /><br /><br /><br />Note that only mutable objects needs to be cloned. References to unchangeable objects such as String be used in the cloned object without worry.<br />"",""Next, let's take a look at applying an adaptor to our design. Adaptors are used to add functionality to the event handling process that:<br /><br />is general to the process and not specific to any one listener; or<br />is not supposed to affect the implementation of specific listeners.<br /><br />According to the Event Model specification a typical use case for an adaptor is to add routing logic for events. But you can also add filtering or logging. In our case, let's do that: add logging of the numbers as \""proof\"" for the calculations done in the listeners.<br />An adaptor, as explained earlier, is a class that sits between the event source and the listeners. From the point of view of the event source, it masquerades as a listener (so it must implement the listener interface). From the point of view of the listeners it pretends to be the event source (so it should have add and remove methods). In other words, to write an adaptor you have to repeat some code from the event source (to manage listeners) and you have to re-implement the event notification methods to do some extra stuff and then pass the event on to the actual listeners.<br />In our case we need an adaptor that writes the numbers to a log file. Keeping it simple once again, let's settle for an adaptor that:<br /><br />Uses a fixed log file name and overwrites that log file with every program run.<br />Opens a FileWriter in the constructor and just keeps it open.<br />Implements the numberRead method by writing the number to the FileWriter.<br />Implements the numberStreamTerminated method by closing the FileWriter.<br /><br />Also, we can make life easy on ourselves by just copying all the code we need to manage listeners over from the NumberReader class. Again, in a real program you'd want to do this differently. Note that each notification method implementation also passes the event on to all the real listeners:<br /><br /><br /><br />Code listing 1.6: NumberReaderLoggingAdaptor.<br /><br /><br />package org.wikibooks.en.javaprogramming.example;<br /><br />import java.io.BufferedWriter;<br />import java.io.FileWriter;<br />import java.io.IOException;<br />import java.util.HashSet;<br />import java.util.Set;<br /><br />public class NumberReaderLoggingAdaptor implements NumberReadListener {<br />    private Set<NumberReadListener> listeners;<br />    private BufferedWriter output;<br />   <br />    public NumberReaderLoggingAdaptor() {<br />        listeners = new HashSet<NumberReadListener>();<br />        try {<br />            output = new BufferedWriter(new FileWriter(\""numberLog.log\""));<br />        } catch (IOException e) {<br />            // TODO Auto-generated catch block<br />            e.printStackTrace();<br />        }<br />    }<br />   <br />    public void addNumberReadListener(NumberReadListener listener) {<br />        this.listeners.add(listener);<br />    }<br />   <br />    public void removeNumberReadListener(NumberReadListener listener) {<br />        this.listeners.remove(listener);<br />    }<br />   <br />   <br />    @Override<br />    public void numberRead(NumberReadEvent numberReadEvent) {<br />        try {<br />            output.write(numberReadEvent.getNumber() + \""\\n\"");<br />        } catch (Exception e) {<br />           <br />        }<br />        for (NumberReadListener numberReadListener: listeners) {<br />            numberReadListener.numberRead(numberReadEvent);<br />        }<br />    }<br /><br />    @Override<br />    public void numberStreamTerminated(NumberReadEvent numberReadEvent) {<br />        try {<br />            output.flush();<br />            output.close();<br />        } catch (Exception e) {<br />           <br />        }<br />        for (NumberReadListener numberReadListener: listeners) {<br />            numberReadListener.numberStreamTerminated(numberReadEvent);<br />        }<br />    }<br /><br />}<br /><br /><br /><br /><br />Of course, to make the adaptor work we have to make some changes to the bootstrap code:<br /><br /><br /><br />Code listing 1.7: Main.<br /><br /><br />package org.wikibooks.en.javaprogramming.example;<br /><br />public class Main {<br /><br />    public static void main(String[] args) {<br />        NumberReader reader = new NumberReader();<br />        NumberReadListener listener = new NumberReadListenerImpl();<br />        NumberReaderLoggingAdaptor adaptor = new NumberReaderLoggingAdaptor();<br />        adaptor.addNumberReadListener(listener);<br />        reader.addNumberReadListener(adaptor);<br />        reader.start();<br />    }<br />}<br /><br /><br /><br /><br />But note how nicely and easily we can re-link the objects in our system. The fact that adaptors and listeners both implement the listener interface and the adaptor and event source both look like event sources means that we can hook the adaptor into the system without having to change a single statement in the classes that we developed earlier.<br />And of course, if we run the same example as given above, the numbers are now recorded in a log file.<br />"",""For comprehensive information about all aspects of Ant, please see the Ant Wikibook.<br /><br />The best way to build your application is to use a build tool. This checks all the needed dependencies and compiles only the needed class for the build. Ant tool is one of the best and the most popular build tools currently available. Ant is a build management tool designed to replace MAKE as the tool for automated builds of large Java applications. Like Java, and unlike MAKE, Ant is designed to be platform independent.<br />Using Ant you would build your application from the command line by typing:<br /><br /><br /><br />Ant building<br /><br />ant build.xml<br /><br /><br /><br />The build.xml file contains all the information needed to build the application.<br />Building a Java application requires certain tasks to be performed defined in a build.xml file. Those tasks may include not only compiling the code, but also copying code, packaging the program to a Jar, creating EJBs, running automated tests, doing ftp for the code to remote site, and so on. For some tasks a condition can be assigned, for example to compile only changed code, or do the task if that was not already done so. Tasks dependency can also be specified, which will make sure that the order of executions of the tasks are in the right order. For example, when compiling the code before packaging it to a jar, the package-to-jar task depends on the compilation task.<br /><br /><br /><br />In rare cases, your code may appear to compile correctly but the program behaves as if you were using an old copy of the source code (or otherwise reports errors during runtime.) When this occurs, you may need to clean your compilation folder by either deleting the class files or using the Clean command from an IDE.<br /><br /><br />The build.xml file is generally kept in the root directory of the java project. Ant parses this file and executes the tasks therein. Below we give an example build.xml file.<br />Ant tool is written in Java and is open source, so it can be extended if there is a task you'd like to be done during the build that is not in the predefined tasks list. It is very easy to hook your ant task code to the other tasks: your code only needs to be in the classpath, and the Ant tool will load it at runtime. For more information about writing your own Ant tasks, please see the project website at http://ant.apache.org/.<br /><br />Example build.xml file.<br /><br /><br /><br /><?xml version=\""1.0\""?><br /><br /><project name=\""ExampleApp\"" basedir=\"".\"" default=\""main\""><br /><br />    <property name=\""source.dir\""    value=\""source\"" /><br />    <property name=\""libraries.dir\"" value=\""libraries\"" /><br />    <property name=\""build.dir\""     value=\""build\"" /><br />    <property name=\""classes.dir\""   value=\""${build.dir}/classes\"" /><br />    <property name=\""dist.dir\""      value=\""${build.dir}/dist\"" /><br />    <property name=\""main-class\""    value=\""com.example.ExampleApp\""/><br /><br />    <path id=\""classpath\""><br />        <fileset dir=\""${libraries.dir}\"" includes=\""**/*.jar\""/><br />    </path><br /><br />    <target name=\""clean\""><br />        <delete dir=\""${build.dir}\""/><br />    </target><br /><br />    <target name=\""compile\""><br />        <mkdir dir=\""${classes.dir}\""/><br />        <javac srcdir=\""${source.dir}\"" destdir=\""${classes.dir}\"" classpathref=\""classpath\"" /><br />        <copy todir=\""${classes.dir}\""><br />            <fileset dir=\""${src.dir}\"" excludes=\""**/*.java\"" /><br />        </copy><br />    </target><br /><br />    <target name=\""build\"" depends=\""compile\""><br />        <mkdir dir=\""${dist.dir}\""/><br />        <copy todir=\""${dist.dir}/lib\"" flatten=\""true\""><br />            <path refid=\""classpath\"" /><br />        </copy><br />        <path id=\""dist.classpath\""><br />            <fileset dir=\""${dist.dir}/lib\"" includes=\""*.jar\"" /><br />        </path><br />        <manifestclasspath property=\""dist.manifest.classpath\"" jarfile=\""${dist.dir}/${ant.project.name}.jar\""><br />            <classpath refid=\""dist.classpath\"" /><br />        </manifestclasspath><br />        <jar destfile=\""${dist.dir}/${ant.project.name}.jar\"" ><br />            <zipfileset dir=\""${classes.dir}\"" /><br />            <manifest><br />                <attribute name=\""Class-Path\"" value=\""${dist.manifest.classpath}\""/><br />                <attribute name=\""Main-Class\"" value=\""${main-class}\"" /><br />            </manifest><br />        </jar><br />    </target><br /><br />    <target name=\""run-build\"" depends=\""build\""><br />        <java jar=\""${dist.dir}/${ant.project.name}.jar\"" fork=\""true\""><br />            <classpath><br />                <path refid=\""classpath\""/><br />                <path location=\""${dist.dir}/${ant.project.name}.jar\""/><br />            </classpath><br />        </java><br />    </target><br /><br />    <target name=\""run\"" depends=\""compile\""><br />        <java classname=\""${main-class}\"" ><br />            <classpath><br />                <path refid=\""classpath\""/><br />                <pathelement location=\""${classes.dir}\"" /><br />            </classpath><br />        </java><br />    </target><br /><br />    <target name=\""clean-build\"" depends=\""clean, build\""/><br /><br />    <target name=\""main\"" depends=\""clean, run\""/><br /><br /></project><br /><br /><br /><br />The next most popular way to build applications is using an Integrated Development Environment (IDE).<br />"",""If you are intent on writing content for this book, you need to do the following:<br /><br />When writing content for this book, you can always pose as an anonymous contributor, however we recommend you sign-in into the Wikibooks website when doing so. It becomes easier to track and acknowledge changes to certain parts of the book. Furthermore, the opinions and views of logged-in users are given precedence over anonymous users.<br />Once you have started contributing content for this book, make sure that you add your name to the contributor list.<br />Be bold and try to follow the conventions for this Wikibook. It is important that the conventions for this book be followed to the letter to make content consistent and reliable throughout.<br /><br /><br /><br /><br /> Introduction<br />Java Programming<br />About This Book<br />History<br />"",""A set collection contains unique elements, so duplicates are not allowed. It is similar to a mathematical Set. When adding a new item to a set, the set calls the method int hashCode() of the item and compare it to the hash code of all the already inserted items. If the hash code has not been found, the item is added. If it is, the set now call the boolean equals(Object obj); method with all the set items. If all calls returns false, the item is inserted. If not, the item is not inserted.<br /><br /><br /><br />Figure 2: Set class diagram.<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />java.util.HashSet<E> <br />This is the basic implementation of the Set interface. Not synchronized. Allows the null elements<br />java.util.TreeSet<E><br />Elements are sorted, not synchronized. null not allowed<br />java.util.CopyOnWriteArraySet<E> <br />Thread safe, a fresh copy is created during modification operation. Add, update, delete are expensive.<br />java.util.EnumSet<E extends Enum<E>> <br />All of the elements in an enum set must come from a single enum type that is specified, explicitly or implicitly, when the set is created. Enum sets are represented internally as bit vectors.<br />java.util.LinkedHashSet<E> <br />Same as HashSet, plus defines the iteration ordering, which is the order in which elements were inserted into the set.<br />"",""After J2EE, Sun had a vision about the next step of network computing: in a network environment, there would be many independent services and consumers. That is JavaSpaces. JavaSpaces would allow these services/consumers to interact dynamically with each other in a robust way. It can be viewed as an object repository that provides a distributed persistent object exchange mechanism (persistent can be in memory or disk) for Java objects. It can be used to store the system state and implement distributed algorithms. In a JavaSpace, all communication partners (peers) communicate by sharing state. It is an implementation of the Tuple spaces idea.<br />JavaSpaces is used when someone wants to achieve scalability and availability and at the same time reducing the complexity of the overall system.<br />Processes perform simple operations to write new objects into a JavaSpace, take objects from a JavaSpace, or read (make a copy of) objects from the JavaSpace.<br />In conventional applications, objects are assembled from the database before presenting to the end user. In JavaSpace applications, we keep the ready made \""end user\"" objects and store them in the JavaSpace. In JavaSpace applications the services are decoupled from each other; they communicate through objects that they write and read/take from the JavaSpace. Services search for objects that they want to take or read from the Space by using template object.<br />""]}"
"{""result"":[""Released in 8 May 2000. The most notable changes were:<br /><br />HotSpot JVM included (the HotSpot JVM was first released in April, 1999 for the J2SE 1.2 JVM)<br />RMI was modified to support optional compatibility with CORBA<br />JavaSound<br />Java Naming and Directory Interface (JNDI) included in core libraries (previously available as an extension)<br />Java Platform Debugger Architecture (JPDA)<br />Synthetic proxy classes<br />"",""In most modern operating systems, a large body of reusable code is provided to simplify the programmer's job. This code is typically provided as a set of dynamically loadable libraries that applications can call at runtime. Because the Java platform is not dependent on any specific operating system, applications cannot rely on any of the existing libraries. Instead, the Java platform provides a comprehensive set of standard class libraries, containing much of the same reusable functions commonly found in modern operating systems.<br />The Java class libraries serve three purposes within the Java platform. Like other standard code libraries, they provide the programmer with a well-known set of functions to perform common tasks, such as maintaining lists of items or performing complex string parsing. In addition, the class libraries provide an abstract interface to tasks that would normally depend heavily on the hardware and operating system. Tasks such as network access and file access are often heavily dependent on the native capabilities of the platform. The Java java.net and java.io libraries implement the required native code internally, then provide a standard interface for the Java applications to perform those tasks. Finally, some underlying platforms may not support all of the features a Java application expects. In these cases, the class libraries can either emulate those features using whatever is available, or provide a consistent way to check for the presence of a specific feature.<br />"",""For example, to compile and run a class from a project's top directory (that contains the two directories /source and /libraries) you could use the following command:<br /><br /><br /><br />Compilation<br /><br />$ javac -classpath libraries/lib.jar source/MainClass.java<br /><br /><br /><br />And then to run it, similarly:<br /><br /><br /><br />Execution<br /><br />$ java -classpath libraries/lib.jar source/MainClass<br /><br /><br /><br />The above is simplified, and demands that MainClass be in the default package, or a package called source, which isn't very desirable.<br />"",""Reflection is the mechanism by which Java exposes the features of a class during runtime, allowing Java programs to enumerate and access a class' methods, fields, and constructors as objects. In other words, there are object-based mirrors that reflect the Java object model, and you can use these objects to access an object's features using runtime API constructs instead of compile-time language constructs. Each object instance has a getClass() method, inherited from java.lang.Object, which returns an object with the runtime representation of that object's class; this object is an instance of the java.lang.Class, which in turn has methods that return the fields, methods, constructors, superclass, and other properties of that class. You can use these reflection objects to access fields, invoke methods, or instantiate instances, all without having compile-time dependencies on those features. The Java runtime provides the corresponding classes for reflection. Most of the Java classes that support reflection are in the java.lang.reflect package. Reflection is most useful for performing dynamic operations with Java — operations that are not hard-coded into a source program, but that are determined at run time. One of the most important aspects of reflection is dynamic class loading.<br />"",""Released on 28 July 2011.<br />Feature additions for Java 7 include:[5]<br /><br />JVM support for dynamic languages, following the prototyping work currently done on the Multi Language Virtual Machine<br />Compressed 64-bit pointers[6] Available in Java 6 with -XX:+UseCompressedOops<br />Small language changes (grouped under a project named Coin):[7]<br /><br /><br /><br /><br />Strings in switch[8]<br />Automatic resource management in try-statement[9]<br />Improved type inference for generic instance creation[10]<br />Simplified varargs method declaration[11]<br />Binary integer literals[12]<br />Allowing underscores in numeric literals[13]<br />Catching multiple exception types and rethrowing exceptions with improved type checking[14]<br /><br /><br /><br /><br />Concurrency utilities under JSR 166[15]<br />New file I/O library to enhance platform independence and add support for metadata and symbolic links. The new packages are java.nio.file and java.nio.file.attribute[16][17]<br />Library-level support for Elliptic curve cryptography algorithms<br />An XRender pipeline for Java 2D, which improves handling of features specific to modern GPUs<br />New platform APIs for the graphics features originally planned for release in Java version 6u10<br />Enhanced library-level support for new network protocols, including SCTP and Sockets Direct Protocol<br />Upstream updates to XML and Unicode<br /><br />Lambda (Java's implementation of lambda functions), Jigsaw (Java's implementation of modules), and part of Coin were dropped from Java 7. Java 8 will be released with the remaining features in summer 2013.[18]<br />"",""In Java, an annotation is a language construct that was introduced in J2SE 1.5 that provides a mechanism for including metadata directly in the source code.<br />Annotations can provide metadata for java classes, attributes, and methods. Syntactically, annotations can be viewed as special kind of modifier and can be used anywhere that other modifiers (such as public, static, or final) can be used<br />One of the main forces of adding this feature to Java was the wide spread use of XML descriptors to add additional information, metadata for Java classes. Frameworks like EJB, JSF, Spring, Hibernate were heavily using external XML descriptors. The problem of those external descriptors is that those files are out of reach of the Java compiler and for that reason compiler type checking could not be used. A small spelling mistake bug in a huge XML descriptor file is hard to locate and fixed. The Java annotations on the other hand use the Java compiler type checking features, so annotation names spelling mistakes will be caught by the Java compiler.<br />In summary, annotations can be...<br /><br />used as a source of information for the compiler;<br />made available for compile-time or deployment-time processing;<br />examined at runtime.<br />"",""To follow these standards, the bean needs one or more properties abstractions which represent different state values of an object. A property has a name (a valid Java identifier) and a type (either a reference type, a primitive type or an array type). By default, the properties of a JavaBean class are inferred by the presence of either a getter method, a setter method, or both:<br /><br />A getter method which is used to obtain the value of the property from a bean. The name is usually of the form getPropertyName. For example, the getter method for the String property whiskey is public String getWhiskey(). For boolean properties (those whose type is boolean, the convention is to use the naming pattern isPropertyName.<br /><br />isDiscounted() would be the getter method for a boolean property named discounted. Thus, the method signature of most getters is public PropertyType getPropertyName() or public boolean isPropertyName().<br /><br />A setter method which is used to assign a value to a bean's property. A setter method is a method of the form public void setPropertyName(PropertyType value). For the previous example, the setter could be invoked as setWhiskey(\""bourbon\"");.<br /><br />As per the JavaBeans standard, getters and setters defined as described above automatically determine the properties of the class. However, by creating java.beans.PropertyDescriptor classes, you can specify alternate implementations by explicitly declaring the property names and the getter and/or setter methods for each property.<br />Properties are often implemented with private instance variables, but this is not required.<br />"",""The .NET framework borrows many of the concepts and innovations of Java — their alternative for the JVM is called the Common Language Runtime (CLR), while their alternative for the byte-code is the Common Intermediate Language (CIL). In fact, the .NET platform had an implementation of a Java-like language called Visual J# (formerly known as J++).<br />J# is normally not supported with the JVM because instead of compiling it in Java byte-code, the .NET platform compiles the code into CIL, thus making J# different from the Java programming language. Furthermore, because J# implements the .NET Base Class Libraries (BCL) instead of the Java Class Libraries, J# is nothing more than a non-standard extension of the Java programming language. Due to the lack of interest from developers, Microsoft had to withdraw their support for J#, and focused on a similar programming language: C#.<br />"",""super is a keyword.<br /><br />It is used inside a sub-class method definition to call a method defined in the super class. Private methods of the super-class cannot be called. Only public and protected methods can be called by the super keyword.<br />It is also used by class constructors to invoke constructors of its parent class.<br /><br />Syntax:<br /><br />super.<method-name>();<br /><br />For example:<br /><br /><br /><br />Code listing 1: SuperClass.java<br /><br /><br />1 public class SuperClass {<br />2    public void printHello() {<br />3       System.out.println(\""Hello from SuperClass\"");<br />4       return;<br />5    }<br />6 }<br /><br /><br /><br /><br /><br /><br /><br />Code listing 2: SubClass.java<br /><br /><br /> 1 public class SubClass extends SuperClass {<br /> 2    public void printHello() {<br /> 3       super.printHello();<br /> 4       System.out.println(\""Hello from SubClass\"");<br /> 5       return;<br /> 6    }<br /> 7    public static main(String[] args) {<br /> 8       SubClass obj = new SubClass();<br /> 9       obj.printHello();<br />10    }<br />11 }<br /><br /><br /><br /><br />Running the above program:<br /><br /><br /><br />Command for Code listing 2<br /><br />$Java SubClass<br /><br /><br /><br /><br /><br /><br />Output of Code listing 2<br /><br />Hello from SuperClass<br />Hello from SubClass<br /><br /><br /><br />In Java 1.5 and later, the \""super\"" keyword is also used to specify a lower bound on a wildcard type parameter in Generics.<br /><br /><br /><br />Code section 1: A lower bound on a wildcard type parameter.<br /><br /><br />1 public void sort(Comparator<? super T> comp) {<br />2   ...<br />3 }<br /><br /><br /><br /><br />See also:<br /><br />extends<br />"",""Released in September 2004<br /><br />Major changes include:<br /><br />Generics - Provides compile-time type safety for collections :and eliminates the drudgery of casting.<br />Autoboxing/unboxing - Eliminates the drudgery of manual conversion between primitive types (such as int) and wrapper types (such as Integer).<br />Enhanced for - Shorten the for loop with Collections use.<br />Static imports - Lets you import all the static part of a class.<br />Annotation/Metadata - Enabling tools to generate code and deployment descriptors from annotations in the source code. This leads to a \""declarative\"" programming style where the programmer says what should be done and tools emit the code to do it. Annotations can be inspected through source parsing or by using the additional reflection APIs added in Java 5.<br />JVM Improvements - Most of the run time library is now mapped into memory as a memory image, as opposed to being loaded from a series of class files. Large portion of the runtime libraries will now be shared among multiple JVM instances.<br />""]}"
"{""result"":[""A client code for a server/service is usually an API that a user application uses to interface to the server. With the help of a client API the user application does not have to know how to connect to the server to get services.<br /><br />ComClient <br />This class is the client API. The application is using this class to communicate with the server.<br /><br />The following is the client class for the above server:<br /><br /><br /><br />Code listing 1.5: ComClient<br /><br /><br /> public class ComClient<br /> {<br />  private Socket         comSocket;<br />  private ObjectOutputStream oOut;<br />  private ObjectInputStream  oIn;<br />  private boolean         IsItOpen = false;       <br />    /**<br />     * --- Open Socket ---<br />     */<br />    public void openCom( String sServerName,<br />                         int    iPortNumber ) throws UnknownHostException,<br />                                                              IOException  <br />    {<br />       try {<br />          // --- Open Socket for communication ---<br />          comSocket = new Socket( sServerName, iPortNumber );     <br />          // --- Get Stream to write request to the Server ---<br />          oOut = new ObjectOutputStream( comSocket.getOutputStream() );     <br />          // --- Get Stream// to read from the Server<br />          oIn = new ObjectInputStream( comSocket.getInputStream());<br />          // --- Set internal Member variable that the Communication opened ---<br />          IsItOpen = true;<br />       } catch ( java.net.UnknownHostException e ) {<br />          System.err.println( \""(openCom:)Don't know about host: \""+sServerName );<br />          IsItOpen = false;<br />          throw( e );                                         <br />       } catch ( java.io.IOException e ) {<br />          System.err.println(\""(openCom:)Couldn't get I/O for the connection to: \""+ sServerName );<br />          IsItOpen = false;<br />          throw( e );         <br />       }               <br />    }<br />    /**<br />     * --- Check if Socket is open ---<br />     */<br />    public boolean isItOpen()<br />    {<br />      return IsItOpen;<br />    }     <br />    /**<br />     * --- Get data string from the Server ---<br />     */<br />    public void getServerData( COM_DATA tServData ) throws IOException<br />    {<br />        // --- Initialize Variables ---<br />        tServData.comData = \""\"";<br />        // --- Get the Response from the Server ---              <br />        try {<br />           tServData.copy( (COM_DATA) oIn.readObject() );<br />        }   <br />        catch ( ClassNotFoundException e ) {<br />            System.out.println( \""Class Not Found\"" );<br />        } <br />        System.out.println( \""Server: \"" + tServData.comData );<br />        if ( tServData.comData.equals(\""BYE.\"") )<br />        {<br />            tServData.bExit = true;<br />        }        <br />     return;<br />    }<br />    /**<br />     * --- Send data to the Server ---<br />     */<br />    public void sendDataToServer( COM_DATA tServData ) throws IOException<br />    {<br />        // --- Send the data string ---<br />        System.out.println( \""Send: \"" + tServData.comData );<br />        oOut.writeObject( tServData );<br />     return;<br />    } <br />    /**<br />     * --- Close Socket --- <br />     */<br />    public void closeCom() throws IOException<br />    {<br />        oOut.close();<br />        oIn.close();<br />        comSocket.close();<br />        IsItOpen = false;<br />    }    <br /> }<br /><br /><br /><br /><br /><br />getServerData( COM_DATA tServData ) <br />This method reads the data from the server and copies the values to tServData object.<br />sendDataToServer( COM_DATA tServData ) <br />This method sends the tServData object through the network to the server.<br />oIn.readObject() <br />This method returns the data object sent by the server.<br />oOut.writeObject( tServData ) <br />This method sends the data object to the server.<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />To do:<br />Add some exercises like the ones in Variables<br /><br /><br /><br /><br /><br /><br /> Basic Synchronization<br />Java Programming<br />Client Server<br />Remote Method Invocation<br />"",""ComServer <br />class is for listening on a port for a client.<br /><br /><br /><br /><br />Code listing 1.1: ComServer<br /><br /><br />import java.net.ServerSocket;<br />/**<br /> * -- Main Server Class; Listening on a port for client; If there is a client,<br /> * starts a new Thread and goes back to listening for further clients. --<br /> */<br />public class ComServer <br />{<br />static boolean  GL_listening = true;<br />   /**<br />    * -- Main program to start the Server --<br />    */<br />   public static void main(String[] args) throws IOException<br />   {<br />      ComServer srv = new ComServer();<br />      srv.listen(); <br />   } // --- End of Main Method ---<br /><br />   /**<br />    * -- Server method; Listen for client --<br />    */<br />   public int listen() throws IOException<br />   {<br />    ServerSocket serverSocket = null;<br />    int iPortNumber = 9090;<br /><br />       // --- Open the Server Socket where this should listen ---<br />       try {<br />           System.out.println( \""*** Open the listening socket; at:\""+ iPortNumber + \"" ***\"" );<br />           serverSocket = new ServerSocket( iPortNumber );<br />       } catch (IOException e) {<br />           System.err.println(\""Could not listen on port:\""+iPortNumber );<br />           System.exit(1);<br />       }<br />       while ( GL_listening )<br />       {<br />        ComServerThread clientServ; <br />           // --- Listening for client; If there is a client start a Thread -<br />           System.out.println( \""*** Listen for a Client; at:\""+ iPortNumber + \"" ***\"" );<br />           clientServ = new ComServerThread( serverSocket.accept() );<br />           // --- Service a Client ---<br />           System.out.println( \""*** A Client came; Service it ***\"" );<br />           clientServ.start();   /* --- Use for multy Threaded --- */<br />      //     clientServ.run();    /* --- Use for Single Threaded --- */<br />       }<br /><br />       // --- Close the Server socket;  Server exiting ---<br />       serverSocket.close();<br />    return 0;<br />   } // --- End of listen Method --- <br />}  // --- End of ComServer Class ---<br /><br /><br /><br /><br /><br />ServerSocket( iPortNumber ) <br />Creates a server socket, bound to the specified port.<br />serverSocket.accept() <br />Listens for a connection to be made to this socket and accepts it. The method blocks until a connection is made. It returns a new Socket.<br />"",""Java language first edition came out in the client-server era. Thick clients were developed with rich GUI interfaces. Java first edition, JSE (Java Standard Edition) had/has the following in its belt:<br /><br />GUI capabilities (AWT, Swing)<br />Network computing capabilities (RMI)<br />Multi-tasking capabilities (Threads)<br /><br />With JSE the following Java code executions are possible:<br /><br /><br /><br /><br />Figure 1: Stand alone execution<br /><br /><br /><br />Stand alone Java application <br />(Figure 1) Stand alone application refers to a Java program where both the user interface and business modules are running on the same computer. The application may or may not use a database to persist data. The user interface could be either AWT or Swing.<br />The application would start with a main() method of a Class. The application stops when the main() method exits, or if an exception is thrown from the application to the JVM. Classes are loaded to memory and compiled as needed, either from the file system or from a *.jar file, by the JVM.<br />Invocation of Java programs distributed in this manner requires usage of the command line. Once the user has all the class files, he needs to launch the application by the following command line (where Main is the name of the class containing the main() method.)<br /><br /><br /><br /><br />Execution of class<br /><br />java Main<br /><br /><br /><br /><br />Java 'jar' class libraries <br />Utility classes, framework classes, and/or third party classes are usually packaged and distributed in Java ' *.jar' files. These 'jar' files need to be put in the CLASSPATH of the java program from which these classes are going to be used.<br />If a jar file is executable, it can be run from the command line:<br /><br /><br /><br /><br />Execution of archive<br /><br />java -jar Application.jar<br /><br /><br /><br /><br /><br /><br /><br />Figure 2: Applet Execution<br /><br /><br /><br />Java Applet code <br />(Figure 2) Java Applets are Java code referenced from HTML pages, by the <APPLET> tag. The Java code is downloaded from a server and runs in the client browser JVM. Java has built-in support to render applets in the browser window.<br />Sophisticated GUI clients were found hard to develop, mostly because of download time, incompatibilities between browser JVM implementations, and communication requirements back to the server. Applets are rarely used today, and are most commonly used as small, separate graphic-like animation applets. The popularity of Java declined when Microsoft withdrew its Java support from Internet Explorer default configuration, however, the plugin is still available as a free download from java.com.<br />More information can be found about applets at the Applet Chapter, in this book. Also, Wikipedia has an article about Java Applets.<br /><br /><br />Client Server applications <br />The client server applications consist of a front-end, and a back-end part, both running on a separate computer. The idea is that the business logic would be on the back-end part of the program, which would be reused by all the clients. Here the challenge is to achieve a separation between front-end user interface code, and the back-end business logic code.<br />The communication between the front-end and the back-end can be achieved by two ways.<br /><br /><br /><br />One way is to define a data communication protocol between the two tiers. The back-end part would listen for an incoming request. Based on the protocol it interprets the request and sends back the result in data form.<br />The other way is to use Java Remote Invocation (RMI). With the use of RMI, a remote object can be created and used by the client. In this case Java objects are transmitted across the network.<br /><br /><br /><br /><br />More information can be found about client-server programming, with sample code, at the Client Server Chapter in this book.<br /><br /><br />Web Applications <br />For applications needed by lots of client installations, the client-server model did not work. Maintaining and upgrading the hundreds or thousands of clients caused a problem. It was not practical. The solution to this problem was to create a unified, standard client, for all applications, and that is the Browser.<br />Having a standard client, it makes sense to create a unified, standard back-end service as well, and that is the Application Server.<br />Web Application is an application that is running in the Application Server, and it can be accessed and used by the Browser client.<br />There are three main area of interest in Web Applications, those are:<br /><br />The Web Browser. This is the container of rendering HTML text, and running client scripts<br />The HTTP protocol. Text data are sent back and forth between Browser and the Server<br />The Web server to serve static content, Application server to serve dynamic content and host EJBs.<br /><br /><br />Wikipedia also has an article about Web application.<br />"",""As the focus was shifting from reaching GUI clients to thin client applications, with Java version 2, Sun introduced J2EE (Java 2 Extended Edition). J2EE added :<br /><br />Components Base Architecture, (Servlet, JSP, EJB Containers)<br /><br />With J2EE the following Java component executions are possible:<br /><br /><br /><br /><br />Figure 3: Servlet Execution<br /><br /><br /><br />Java Servlet code <br />(Figure 3) Java got its popularity with server side programming, more specifically with J2EE servlets. Servlets are running in a simple J2EE framework to handle client HTTP requests. They are meant to replace CGI programming for web pages rendering dynamic content.<br />The servlet is running in a so called servlet-container/web container. The servlet's responsibility is to:<br /><br />Handle the request by doing the business logic computation,<br />Connecting to a database if needed,<br />Create HTML to present to the user through the browser<br /><br /><br />The HTML output represents both the presention logic and the results of the business computations. This represents a huge problem, and there is no real application relying only on servlets to handle the presention part of the responsibility. There are two main solutions to this:<br /><br />Use a template tool (Store the presentation part in an HTML file, marking the areas that need to be replaced after business logic computations).<br />Use JSP (See next section)<br /><br /><br />Wikipedia also has an article about Servlets.<br /><br /><br /><br /><br /><br />Figure 4: Jsp Execution<br /><br /><br /><br />Java Server Pages (JSP) code <br />(Figure 4) JSP is an HTML file with embedded Java code inside. The first time the JSP is accessed, the JSP is converted to a Java Servlet. This servlet outputs HTML which has inside the result of the business logic computation. There are special JSP tags that helps to add data dynamically to the HTML. Also JSP technology allows to create custom tags.<br />Using the JSP technology correctly, business logic computations should not be in the embedded Java part of the JSP. JSP should be used to render the presentation of the static and dynamic data. Depending on the complexity of the data, 100% separation is not easy to achieve. Using custom tags, however may help to get closer to 100%. This is advocated also in MVC architecture (see below).<br /><br /><br /><br /><br /><br />Figure 5: EJB Execution<br /><br /><br /><br />EJB code <br />(Figure 5) In the 1990s, with the client server computing, a trend started, that is to move away from Mainframe computing. That resulted in many small separate applications in a Company/Enterprise. Many times the same data was used in different applications. A new philosophy, \""Enterprise Computing\"", was created to address these issues. The idea was to create components that can be reused throughout the Enterprise. The Enterprise Java Beans (EJBs) were supposed to address this.<br />An EJB is an application component that runs in an EJB container. The client accesses the EJB modules through the container, never directly. The container manages the life cycle of the EJB modules, and handles all the issues that arise from network/enterpise computing. Some of those are security/access control, object pooling, transaction management, ... .<br />EJBs have the same problems as any reusable code: they need to be generic enough to be able to be reused and the changes or maintenance of EJBs can affect existing clients. Many times EJBs are used unnecessarily when they are not really needed. An EJB should be designed as a separate application in the enterprise, fulfilling one function.<br /><br /><br /><br /><br /><br /><br />Figure 6: MVC Execution<br /><br /><br /><br />Combine J2EE components to create an MVC architecture <br />This leads us to the three layers/tiers as shown in (Figure 6).<br />In modern web applications, with lots of static data and nice graphics, how the data is presented to the user became very important and usually needs the help of a graphic artist.<br />To help programmers and graphic artists to work together, the separation between data, code, and how it is presented became crucial.<br /><br /><br />The view (User Interface Logic) contains the logic that is necessary to construct the presentation. This could be handled by JSP technology.<br />The servlet acts as the controller and contains the logic that is necessary to process user events and to select an appropriate response.<br />The business logic (model) actually accomplishes the goal of the interaction. This might be a query or an update to a database. This could be handled by EJB technology.<br /><br /><br />For more information about MVC, please see MVC.<br />"",""ComServerThread <br />This class extended from a Thread; Responsible to service one client. The Socket connection will be open between the client and server. A simple protocol has to be defined between the client and server, the server has to understand what the client wants from the server. The client will send a terminate command, for which the server will terminate the socket connection. The ComServerThread class is responsible to handle a client request, until the client sends a terminate command.<br /><br /><br /><br /><br />Code listing 1.2: ComServerThread<br /><br /><br /> /**<br />  * -- A class extended from a Thread; Responsible to service one client --<br />  */<br /> class '''ComServerThread''' extends Thread<br /> {<br />    private Socket clientSocket = null;<br />    COM_DATA tDataFromClient;<br />    COM_DATA tDataToClient; <br />    ObjectInputStream oIn;<br />    ObjectOutputStream oOut;<br />    /**<br />     * -- Constructor --<br />     */<br />    public ComServerThread( Socket socket )<br />    {<br />       super( \""ComServerThread\"" );<br />       this.clientSocket = socket;<br />    } // -- End of ComServerThread() constructor --<br />    /**<br />     * -- Overrun from the Thread (super) class --<br />     */<br />    public void run()<br />    {<br />       try {<br />          // --- Create the Writer; will be used to send data to client ---<br />          oOut = new ObjectOutputStream( clientSocket.getOutputStream() );<br />          // --- Create the Reader; will be used to get data from client ---<br />          oIn  = new ObjectInputStream( clientSocket.getInputStream() );<br />          // --- Create a new protocol object ---<br />          ComProtocol comp = new ComProtocol();<br />          // --- Send something to client to indicate that server is ready ---<br />          tDataToClient  = '''comp.processInput( null );'''<br />          '''sendDataToClient'''( tDataToClient, oOut );<br />          // --- Get the data from the client ---<br />          while ( true )<br />          {<br />             try {<br />                tDataFromClient = '''getDataFromClient( oIn )''';<br />                // --- Parse the request and get the reply ---<br />                tDataToClient = '''comp.processInput( tDataFromClient );'''<br />                // --- Send data to the Client ---<br />                '''sendDataToClient'''( tDataToClient, oOut );<br />             }<br />             catch ( EOFException e ) {<br />                System.out.println( \""Client Disconnected, Bye, Bye\"" );<br />                break;<br />             }<br />             // --- See if the Client wanted to terminate the connection ---<br />             if ( tDataToClient.bExit )<br />             {<br />                System.out.println( \""Client said Bye. Bye\"" );<br />                break;<br />             }<br />          }<br />          // --- Close resources;  This client is gone ---<br />          comp.Final();<br />          oOut.close();<br />          oIn.close();<br />          clientSocket.close();<br />       } catch ( IOException e ) {<br />        e.printStackTrace();<br />       }<br />    } // -- End of run() Method --<br />    /**<br />     * Get data from Client <br />     */<br />    private static COM_DATA '''getDataFromClient'''( ObjectInputStream oIn ) throws IOException                                                                         <br />    {<br />        COM_DATA  tDataFromClient = null;         <br />        // --- Initialize variables ---<br />        //   tDataFromClient = new COM_DATA();<br />        while ( tDataFromClient == null )<br />        {<br />           try {<br />              // --- Read Line Number first --<br />              tDataFromClient = (COM_DATA) oIn.readObject();<br />           } catch ( ClassNotFoundException e ) {<br />               System.out.println( \""ClassNotFound\"" );<br />           }<br />        }<br />        System.out.println( \""Get: \"" + tDataFromClient.comData );<br />     return tDataFromClient;<br />    } // --- getDataFromClient() Method --- <br />    /**<br />     * Send data to Client <br />     */<br />    private static void '''sendDataToClient'''( COM_DATA tDataToClient,<br />                                           ObjectOutputStream  oOut ) throws IOException<br />    {         <br />        System.out.println( \""Sent: \"" + tDataToClient.comData );<br />        oOut.writeObject( tDataToClient );<br />      return;<br />    } // -- End of sendDataToClient() Method --<br /> } // --- End of ComServerThread class ---<br /><br /><br /><br /><br /><br />COM_DATA tDataFromClient <br />This variable will contain the data object from the client.<br />COM_DATA tDataToClient <br />This variable will contain the data object to be sent to the client.<br />sendDataToClient <br />This method sends the data object to the client.<br />getDataFromClient <br />This method gets the data object from the client.<br />processInput( tDataFromClient ) <br />This method of the class ComProtocol interprets the client commands and returns the data object that will be sent back to the client.<br />"",""C++ was built atop the C language and as a result divergent ways of doing the same thing manifested around the language. For instance, creating an object could be done in three different ways in C++. Furthermore, C++ did not come with a standard library bundled with its compilers. Instead, it relied on resources created by other programmers; code which rarely fit together.<br />In Java, standardized libraries are provided to allow access to features of the host machines (such as graphics and networking) in unified ways. The Java language also includes support for multi-threaded programs—a necessity for many networking applications.<br />Platform independent Java is, however, very successful with server side applications, such as web services, servlets, or Enterprise JavaBeans.<br /><br /><br /><br /><br />Swing does not rely on the underlying native user interface.<br /><br /><br />Java also made progress on the client side, first it had Abstract Window Toolkit (AWT), then Swing, and the most recent client side library is the Standard Widget Toolkit (SWT). It is interesting to see how they tried to handle the two opposing consuming forces. Those are :<br /><br />Efficient, fast code; port to most popular hardware (write once, test anywhere) <br />Use the underlying native subroutine to create a GUI component. This approach was taken by AWT, and SWT.<br /><br /><br />Portability to any hardware where JVM ported (write once, run anywhere) <br />To achieve this to the latter, the Java toolkit should not rely on the underlying native user interface. Swing tooks this approach.<br /><br />It is interesting to see how the approach was switched back and forth. AWT → Swing → SWT.<br />"",""After J2EE Sun had a vision about the next step of network computing. That is Jini. The main idea is that in a network environment, there would be many independent services and consumers. Jini would allow these services/consumers to interact dynamically with each other in a robust way. The basic features of Jini are:<br /><br />No user intervention is needed when services are brought on or offline. (In contrast to EJBs where the client program has to know the server and port number where the EJB is deployed, in Jini the client is supposed to find, to discover, the service in the network.)<br />Self healing by adapting when services (consumers of services) come and go. (Services periodically need to renew a lease to indicate that they are still available.)<br />Consumers of JINI services do not need prior knowledge of the service's implementation. The implementation is downloaded dynamically and run on the consumer JVM, without configuration and user intervention. (For example, the end user may be presented with a slightly different user interface depending upon which service is being used at the time. The implementation of the user interface code would be provided by the service being used.)<br /><br />A minimal Jini network environment consists of:<br /><br />One or more services<br />A lookup-service keeping a list of registered services<br />One or more consumers<br /><br />Jini is not widely used at the current writing (2006). There are two possible reasons for it. One is Jini a bit complicated to understand and to set it up. The other reason is that Microsoft pulled out from Java, which caused the industry to turn to the use of proprietary solutions.<br /><br /><br /><br /> Compiling programs<br />Java Programming<br />Execution<br />Understanding a Java Program<br />"",""JavaSpaces technology is part of the Java Jini technology. The basic features of JINI are:<br /><br />No user intervention is needed when services are brought on or offline. (In contrast to EJBs where the client program has to know the server and port number where the EJB is deployed. In JINI the client is supposed to find, discover the service in the network.)<br />Self healing by adapting when services (consumers of services) come and go. Services need to periodically renew a lease to indicate that they are still available.<br />Consumers of JINI services do not need prior knowledge of the service's implementation. The implementation is downloaded dynamically and run on the consumer JVM, without configuration and user intervention. For example, the end user may be presented with slightly different user interface depending which service is being used at the time. The implementation of those user interface code would be provided by the service being used.<br /><br /><br />This fact that the implementation is running on the consumer/client's JVM can increase performance, by eliminating the need of remote calls.<br /><br />A minimal JINI network environment consists of:<br /><br />One or more services<br />A lookup-service keeping a list of registered services<br />One or more consumers<br />"",""Although memory spaces have their own addresses — usually a hash number such as 0xCAD3, etc. — it is much easier to remember a variable's location in the memory if we can give it a recognizable name. Identifiers are the names we give to our variables. You can name your variable anything like aVariable, someVariable, age, someonesImportantData, etcetera. But notice: none of the names we described here has a space within it. Hence, it is pretty obvious that spaces aren't allowed in variable names. In fact, there are a lot of other things that are not allowed in variable names. The things that are allowed are:<br /><br />Characters A to Z and their lower-case counterparts a to z.<br />Numbers 0 to 9. However, numbers should not come at the beginning of a variable's name.<br />And finally, special characters that include only $ (dollar sign) and _ (underscore).<br /><br /><br />Test your knowledge<br /><br />Question 3.6: Which of the ones below are proper variable identifiers?<br /><br />f_name<br />lastname<br />someones name<br />$SomeoneElsesName<br />7days<br />TheAnswerIs42<br /><br /><br />Answer<br /><br />I can tell you that 3 and 5 are not the right way to do things around here, the rest are proper identifiers.<br /><br /><br /><br /><br />Any valid variable names might be correct but they are not always what you should be naming your variables for a few reasons as listed below:<br /><br />The name of the variable should reflect the value within them.<br />The identifier should be named following the naming guidelines or conventions for doing so. We will explain that in a bit.<br />The identifier shouldn't be a nonsense name like lname, you should always name it properly: lastName is the best way of naming a variable.<br />"",""In conventional languages like C and C++, the programmer has to make sure that all memory that was allocated is freed. Memory leaks became a regular nuisance in instances where the programmers had to manually allocate the system's memory resources.<br />Memory resources or buffers have specific modes of operation for optimal performance. Once a buffer is filled with data, it needs to be cleaned up after there is no further use for its content. If a programmer forgets to clean it in his/her code, the memory is easily overloaded. Programming in C/C++ languages became tedious and unsafe because of these very quirks, and programs built in these languages were prone to memory leakages and sudden system crashes — sometimes even harming the hardware itself. Freeing memory is particularly important in servers, since it has to run without stopping for days. If a piece of memory is not freed after use and the server just keeps allocating memory, that memory leak can take down the server.<br />In Java, freeing up memory is taken out of the programmers hands; the Java Virtual Machine keeps track of all used memory. When memory is not used any more it is automatically freed up. A separate task is running in the background by the JVM, freeing up unreferenced, unused memory. That task is called the Garbage Collector.<br />The Garbage Collector is always running. This automatic memory garbage collection feature makes it easy to write robust server side programs in Java. The only thing the programmer has to watch for is the speed of object creation. If the application is creating objects faster than the Garbage Collector can free them, it can cause memory problems. Depending on how the JVM is configured, the application either can run out of memory by throwing the NotEnoughMemoryException, or can halt to give time for the Garbage Collector to do its job.<br />""]}"
"{""result"":[""transient is a Java keyword which marks a member variable not to be serialized when it is persisted to streams of bytes. When an object is transferred through the network, the object needs to be 'serialized'. Serialization converts the object state to serial bytes. Those bytes are sent over the network and the object is recreated from those bytes. Member variables marked by the java transient keyword are not transferred; they are lost intentionally.<br />Syntax:<br /><br />private transient <member-variable>;<br />or <br />transient private <member-variable>;<br /><br /><br />For example:<br /><br /><br /><br /><br /><br /><br />public class Foo implements Serializable<br /> {<br />   private String saveMe;<br />   private transient String dontSaveMe;<br />   private transient String password;<br />   //...<br /> }<br /><br /><br /><br /><br />See also:<br /><br />Java language specification reference: jls<br />Serializable Interface. Serializable<br />"",""You can specify a restriction on the types of classes that may be used. For example, <? extends ClassName> only allows objects of class ClassName or a subclass. For example, to create a collection that may only contain \""Serializable\"" objects, specify:<br /><br /><br /><br />Code section 4.40: Collection of serializable subobjects.<br /><br /><br />1 Collection<String> textColl = new ArrayList<String>();<br />2 <br />3 Collection<? extends Serializable> serColl = textColl;<br /><br /><br /><br /><br />The above code is valid because the String class is serializable. Use of a class that is not serializable would cause a compilation error. The added items can be retrieved as Serializable object. You can call methods of the Serializable interface or cast it to String. The following collection can only contain objects that extend the class Animal.<br /><br /><br /><br />Code listing 4.38: Dog.java<br /><br /><br />1 class Dog extends Animal {<br />2 }<br /><br /><br /><br /><br /><br /><br /><br />Code section 4.41: Example of subclass.<br /><br /><br />1 // Create \""Animal Collection\"" variable<br />2 Collection<? extends Animal> animalColl = new ArrayList<Dog>();<br />"",""The requirements for an object to be a bean is to define a public parameterless constructor, so that beans can be instantiated by builder tools in an uncomplicated way (In the Point bean, the parameterless constructor is given implicitly). Secondly, one of the interfaces java.io.Serializable or java.io.Externalizable need to be implemented. The interfaces do not prescribe the implementation of any methods, but are an approval, that the bean may be saved in persistent storage as in a file or database. In doing so, the bean can be restored after an application was shut down or transferred across networks. The ability to store state of a component in persistent storage is called persistence. Java offers a standard serialization mechanism, which makes it very easy to serialize objects. Alternatively, a component can be stored in a customized manner (e.g. in xml format) by implementing the Externalizable interface.<br />"",""When an object is sent through a network, the object needs to be recreated at the receiving host.<br /><br />Object Serialization <br />The term Object Serialization refers to the act of converting the object to a byte stream. The byte stream can be stored on the file system, or can be sent through a network.<br />At the later time the object can be re-created from that stream of bytes. The only requirement is that the same class has to be available at both times, when the object is serialized and also when the object is re-created. If that happens in different servers, then the same class must be available on both servers. Same class means that exactly the same version of the class must be available, otherwise the object won't be able to be re-created. This is a maintenance problem to those applications where java serialization is used to persist object or sent the object through the network.<br />When a class is modified, there could be a problem re-creating those objects that were serialized using an earlier version of the class.<br /><br />Java has built-in support for serialization, using the Serializable interface; however, a class must first implement the Serializable interface.<br />By default, a class will have all of its fields serialized when converted into a data stream (with transient fields being skipped). If additional handling is required beyond the default of writing all fields, you need to provide an implementation for methods:<br /><br />private void writeObject(java.io.ObjectOutputStream out) throws IOException;<br /><br /><br />private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;<br /><br /><br />private void readObjectNoData() throws ObjectStreamException;<br /><br />If the object needs to write or provide a replacement object during serialization, it needs to implement the following two methods, with any access specifier:<br /><br />Object writeReplace() throws ObjectStreamException;<br /><br /><br />Object readResolve() throws ObjectStreamException;<br /><br />Normally, a minor change to the class can cause the serialization to fail. You can still allow the class to be loaded by defining the serialization version id:<br /><br /><br /><br />Code section 4.32: Serialization version id.<br /><br /><br />1 private static final long serialVersionUID = 42L;<br />"",""As an example, we can show a thread-safe version of a singleton:<br /><br /><br /><br />Code listing 1: Singleton.java<br /><br /><br /> 1 /**<br /> 2  * The singleton class that can be instantiated only once with lazy instantiation<br /> 3  */<br /> 4 public class Singleton {<br /> 5     /** Static class instance */<br /> 6     private volatile static Singleton instance = null;<br /> 7 <br /> 8     /**<br /> 9      * Standard private constructor<br />10      */<br />11     private Singleton() {<br />12         // Some initialisation<br />13     }<br />14    <br />15     /**<br />16      * Getter of the singleton instance<br />17      * @return The only instance<br />18      */<br />19     public static Singleton getInstance() {<br />20         if (instance == null) {<br />21             // If the instance does not exist, go in time-consuming<br />22             // section:<br />23             synchronized (Singleton.class) {<br />24                 if (instance == null) {<br />25                     instance = new Singleton();<br />26                 }<br />27             }<br />28         }<br />29 <br />30         return instance;<br />31     }<br />32  }<br />"",""Since Java 1.5, the class java.lang.Class is generic. It is an interesting example of using generics for something other than a container class. For example, the type of String.class is Class<String>, and the type of Serializable.class is Class<Serializable>. This can be used to improve the type safety of your reflection code. In particular, since the newInstance() method in Class now returns T, you can get more precise types when creating objects reflectively. Now we can use the newInstance() method to return a new object with exact type, without casting. An example with generics:<br /><br /><br /><br />Code section 4.48: Automatic cast.<br /><br /><br /> 1 Customer cust = Utility.createAnyObject(Customer.class);  // No casting<br /> 2 ...<br /> 3 public static <T> T createAnyObject(Class<T> cls) {<br /> 4     T ret = null;<br /> 5     try {<br /> 6         ret = cls.newInstance();<br /> 7     } catch (Exception e) {<br /> 8         // Exception Handling<br /> 9     }<br />10     return ret;<br />11 }<br /><br /><br /><br /><br />The same code without generics:<br /><br /><br /><br />Code section 4.49: Former version.<br /><br /><br /> 1 Customer cust = (Customer) Utility.createAnyObject(Customer.class);  // Casting is needed<br /> 2 ...<br /> 3 public static Object createAnyObject(Class cls) {<br /> 4     Object ret = null;<br /> 5     try {<br /> 6         ret = cls.newInstance();<br /> 7     } catch (Exception e) {<br /> 8         // Exception Handling<br /> 9     }<br />10     return ret;<br />11 }<br />"",""Remote objects can be listed in the RMI Registry. Clients can get a reference to the remote object by querying the Registry. After that, the client can call methods on the remote objects. (Remote object references can also be acquired by calling other remote methods. The Registry is really a 'bootstrap' that solves the problem of where to get the initial remote reference from.)<br />The RMI Registry can either be started within the server JVM, via the LocateRegistry.createRegistry() API, or a separate process called rmiregistry that has to be started before remote objects can be added to it, e.g. by the command line in Unix:<br /><br /><br /><br />rmiregistry on Unix<br /><br />rmiregistry <port> &<br /><br /><br /><br />or under Windows:<br /><br /><br /><br />rmiregistry on Windows<br /><br />start rmiregistry <port><br /><br /><br /><br />If port is not specified the default 1099 is used. The client will need to connect to this port to access the Registry.<br />The Registry can also be started from a program by calling the following code:<br /><br /><br /><br />Code section 1: rmiregistry starting<br /><br /><br />import java.rmi.registry.LocateRegistry;<br />...<br />Registry reg = LocateRegistry.createRegistry(iPort);<br /><br /><br /><br /><br />Objects passed in as parameters to the remote objects's methods will be passed by value. If the remote object changes the passed-in object values, it won't be reflected on the client side, this is opposite what happens when a local object is called. Objects that used as parameters for remote methods invocation must implement the java.io.Serializable interface, as they are going to be serialized when passed through the network, and a new object will be created on the other side.<br />However, exported remote objects passed as parameters are passed by remote reference.<br />"",""/** Grades of courses */<br />  enum Grade { A, B, C, D, F };<br />  // ...<br />  private Grade gradeA = Grade.A;<br /><br /><br /><br /><br /><br />This enumeration constant then can be passed in to methods:<br /><br /><br /><br /><br /><br /><br />student.assignGrade(gradeA);<br />  /**<br />   * Assigns the grade for this course to the student<br />   * @param GRADE  Grade to be assigned<br />   */<br />  public void assignGrade(final Grade GRADE) {<br />    grade = GRADE;<br />  }<br /><br /><br /><br /><br /><br />An enumeration may also have parameters:<br /><br /><br /><br /><br /><br /><br />public enum DayOfWeek {<br />  /** Enumeration constants */<br />  MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(0);<br /><br />  /** Code for the days of the week */<br />  private byte dayCode = 0;<br /><br />  /**<br />   * Private constructor<br />   * @param VALUE  Value that stands for a day of the week.<br />   */<br />  private DayOfWeek(final byte VALUE) {<br />    dayCode = java.lang.Math.abs(VALUE%7);<br />  }<br /> <br />  /**<br />   * Gets the day code<br />   * @return  The day code<br />   */<br />  public byte getDayCode() {<br />    return dayCode;<br />  }<br />}<br /><br /><br /><br /><br /><br />It is also possible to let an enumeration implement interfaces other than java.lang.Comparable and java.io.Serializable, which are already implicitly implemented by each enumeration:<br /><br /><br /><br /><br /><br /><br />public enum DayOfWeek implements Runnable {<br />  MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;<br /> <br />  /**<br />   * Run method prints all elements<br />   */<br />  public void run() {<br />    System.out.println(\""name() = \"" + name() +<br />      \"", toString() = \\\""\"" + toString() + \""\\\""\"");<br />  }<br />}<br />"",""To easily remember what can be done in method overriding, keep in mind that all you can do on an object of a class outside this class, you can do it also on an object of a subclass, only the behavior can change. A subclass should be covariant.<br />Although a method signature has to be unique inside a class, the same method signature can be defined in different classes. If we define a method that exists in the super class then we override the super class method. It is called method overriding. This is different from method overloading. Method overloading happens with methods with the same name different signature. Method overriding happens with same name, same signature between inherited classes.<br />The return type can cause the same problem we saw above. When we override a super class method the return type also must be the same. If that is not the same, the compiler will give you an error.<br />Beware! If a class declares two public methods with the same name, and a subclass overrides one of them, the subclass still inherits the other method. In this respect, the Java programming language differs from C++.<br />Method overriding is related dynamic linking, or runtime binding. In order for the Method Overriding to work, the method call that is going to be called can not be determined at compilation time. It will be decided at runtime, and will be looked up in a table.<br /><br /><br /><br />Code section 4.31: Runtime binding.<br /><br /><br /> 1 MyClass obj;<br /> 2 <br /> 3 if (new java.util.Calendar().get(java.util.Calendar.AM_PM) == java.util.Calendar.AM) {<br /> 4   // Executed a morning<br /> 5   obj = new SubOfMyClass();<br /> 6 } else {<br /> 7   // Executed an afternoon<br /> 8   obj = new MyClass();<br /> 9 }<br />10  <br />11 obj.myMethod();<br /><br /><br /><br /><br /><br />In the code section 4.31, the expression at line 3 is true if it is executed a morning and false if it is executed an afternoon. Thus, the instance of obj will be a MyClass or a SubOfMyClass depending on the execution time. So it is impossible to determine the method address at compile time. Because the obj reference can point to object and all its sub object, and that will be known only at runtime, a table is kept with all the possible method addresses to be called. Do not confuse:<br /><br /><br /><br />Code section 4.32: Declared type and instantiated type.<br /><br /><br />1 obj.myMethod(myParameter);<br /><br /><br /><br /><br />The implementation of this method is searched using the instantiated type of the called object (obj) and the declared type of the parameter object (myParameter).<br />Also another rule is that when you do an override, the visibility of the new method that overrides the super class method can not be reduced. The visibility can be increased, however. So if the super class method visibility is public, the override method can not be package, or private. An override method must throw the same exceptions as the super class, or their subexceptions.<br />super references to the parent class (i.e. super.someMethod()). It can be used in a subclass to access inherited methods that the subclass has overridden or inherited fields that the subclass has hidden.<br /><br /><br /><br />A common mistake to think that if we can override methods, we could also override member variables. This is not the case, as it is useless. You can redefine a variable that is private in the super class as such a variable is not visible.<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />To do:<br />Add some exercises like the ones in Variables<br /><br /><br /><br /><br /><br /><br /> Interfaces<br />Java Programming<br />Overloading Methods and Constructors<br />Object Lifecycle<br />"",""One way to understand how reflection works is to use reflection to model how the Java Runtime Environment (JRE) loads and executes a class. When you invoke a Java program<br /><br /><br /><br />Console<br /><br />java fully-qualified-class-name arg0 ... argn<br /><br /><br /><br /><br />and pass it command line arguments, the JRE must<br /><br />put the command line arguments arg0 ... argn into a String[] array<br />dynamically load the target class named by fully-qualified-class-name<br />access the public static void main(String[]) method<br />invoke the main method, passing the string array main String[].<br /><br />Steps 2, 3, and 4 can be accomplished with Java reflection. Below is an example of loading the Distance class, locating the main method, (see Understanding a Java Program) and invoking it via reflection.<br /><br /><br /><br />Code section 10.1: main() method invocation.<br /><br /><br /> 1 public static void invokeMain()<br /> 2    throws ClassNotFoundException,<br /> 3    \tExceptionInInitializerError,<br /> 4    \tIllegalAccessException,<br /> 5    \tIllegalArgumentException,<br /> 6    \tInvocationTargetException,<br /> 7    \tNoSuchMethodException,<br /> 8    \tSecurityException {<br /> 9    Class<?> distanceClass = Class.forName(\""Distance\"");<br />10    String[] points = {\""0\"", \""0\"", \""3\"", \""4\""};<br />11    Method mainMethod = distanceClass.getMethod(\""main\"", String[].class);<br />12    Object result = mainMethod.invoke(null, (Object) points);<br />13 }<br /><br /><br /><br /><br />This code is obviously more complicated than simply calling<br /><br /><br /><br />Code section 10.2: main() method calling.<br /><br /><br />1 Distance.main(new String[]{\""0\"", \""0\"", \""3\"", \""4\""});<br /><br /><br /><br /><br />However, the main Java runtime does not know about the Distance class. The name of the class to execute is a runtime value. Reflection allows a Java program to work with classes even though the classes are not known when the program was written. Let's explore what the invokeMain method is doing. The first statement at line 9 is an example of dynamic class loading. The forName() method will load a Java class and return an instance of java.lang.Class that results from loading the class. In this case, we are loading the class \""Distance\"" from the default package. We store the class object in the local variable distanceClass; its type is Class<?>. The second statement at line 10 simply creates a String array with the four command line arguments we wish to pass to the main method of the Distance class. The third statement at line 11 performs a reflection operation on the Distance class. The getMethod() method is defined for the Class class. It takes a variable number of parameters: the method name is the first parameter and the remaining parameters are the types of each of main's parameters. The method name is trivial: we want to invoke the main method, so we pass in the name \""main\"". We then add a Class variable for each of the method parameters. main accepts one parameter (String[] args) so we add a single Class element representing the String[]. The getMethod method has a return type of java.lang.reflect.Method; we store the result in a local variable named mainMethod. Finally, we invoke the method by calling the invoke() method of the Method instance. This method's first parameter is the instance to invoke on, and the remaining parameters are for the invokee's parameters. Since we are invoking a static method and not an instance method, we pass null as the instance argument. Since we only have a single parameter we pass it as the second argument. However, we must cast the parameter to Object to indicate that the array is the parameter, and not that the parameters are in the array. See varargs for more details on this.<br /><br /><br /><br />Code section 10.3: invoke() call.<br /><br /><br />1 Object result = mainMethod.invoke(null, arguments);<br /><br /><br /><br /><br />The invoke() method returns an Object that will contain the result that the reflected method returns. In this case, our main method is a void method, so we ignore the return type. Most of the methods in this short invokeMain method may throw various exceptions. The method declares all of them in its signatures. Here is a brief rundown of what might throw an exception:<br /><br />Class.forName(String) will throw ClassNotFoundException, if the named class cannot be located.<br />Class.forName(String) will throw ExceptionInInitializerError, if the class could not be loaded due the static initializer throwing an exception or a static field's initialization throwing an exception.<br />Class.getMethod(String name, Class parameterTypes[]) will throw<br /><br />NoSuchMethodException, if a matching method is not found, or is not public (use getDeclaredMethod to get a non-public method).<br />SecurityException, if a security manager is installed and calling the method would result in an access violation (for example, the method is in the sun.* package designed for internal use only).<br /><br /><br />Method.invoke(Object instance, Object... arguments) may throw:<br /><br />IllegalAccessException, if this method is invoked in a manner that violates its access modifiers.<br />IllegalArgumentException for various reasons, including<br /><br />passing an instance that does not implement this method.<br />the actual arguments do not match the method's arguments<br /><br /><br />InvocationTargetException, if the underlying method (main in this case) throws an exception.<br /><br /><br /><br />In addition to these exceptions, there are also errors and runtime exceptions that these methods may throw.<br /><br /><br /><br /><br /><br /><br /><br />To do:<br />Add some exercises like the ones in Variables<br /><br /><br /><br /><br /><br /><br /> Graphics and Media<br />Java Programming/Reflection<br />Overview<br />Dynamic Class Loading<br />""]}"
